\subsection{Abelian categories}\label{subsec:abelian_categories}

\begin{definition}\label{def:monoidal_category}\cite{MacLane1994}[158]
  A \textbf{monoidal category} is a generalization of A monoid\Tinyref{def:group} from sets to categories. Formally, it is a category \( \Bold M \) along with
  \begin{itemize}
    \item a functor \( \otimes: C \times C \to C \)
    \item an identity object \( 1 \in \Bold M \)
    \item natural transformations
    \begin{itemize}
      \item[] \( \alpha: ((-) \otimes (-)) \otimes (-) \cong (-) \otimes ((-) \otimes (-)) \)
      \item[] \( \lambda: 1 \times (-) \cong (-) \)
      \item[] \( \rho: (-) \times 1 \cong (-) \)
    \end{itemize}
  \end{itemize}
  such that
  \begin{defenum}
    \item for every object \( A \in \Bold M \),
    \begin{align*}
      1 \otimes A \overset {\lambda_a} \cong A
      \\
      A \otimes 1 \overset {\rho_a} \cong A
    \end{align*}

    \item for all objects \( A, B, C \in \Bold M \),
    \begin{equation*}
      A \otimes (B \otimes C) \overset {\alpha_{A,B,C}} \cong (A \otimes B) \otimes C
    \end{equation*}

    \item the following diagram commutes for all objects \( A, B, C, D \in \Bold M \)
    \begin{Center}
      \begin{tikzcd}
                                                                                                                                   & (A \otimes B) \otimes (C \otimes D) \arrow[rd, "{\alpha_{(A \otimes B), C, D}}"] &                                                                                 \\
        A \otimes (B \otimes (C \otimes D)) \arrow[ru, "{\alpha_{A,B,(C \otimes D)}}"] \arrow[dd, "{\Id \otimes \alpha_{B,C,D}}"'] &                                                                                  & ((A \otimes B) \otimes C) \otimes D                                             \\
                                                                                                                                   &                                                                                  &                                                                                 \\
        A \otimes ((B \otimes C) \otimes D) \arrow[rr, "{\alpha_{A,(B \otimes C), D}}"]                                            &                                                                                  & (A \otimes (B \otimes C)) \otimes D \arrow[uu, "{\alpha_{A,B,C} \otimes \Id}"']
      \end{tikzcd}
    \end{Center}

    \item the following diagram commutes for all objects \( A, B \in \Bold M \)
    \begin{Center}
      \begin{tikzcd}
        A \otimes (1 \otimes B) \arrow[rd, "\Id \otimes \lambda_b"'] \arrow[rr, "{\alpha_{A,1,B}}"] &             & (A \otimes 1) \otimes B \arrow[ld, "\rho_a \otimes \Id"] \\
                                                                                                    & A \otimes B &
      \end{tikzcd}
    \end{Center}
  \end{defenum}

  If the natural isomorphisms \( \alpha \), \( \lambda \) and \( \rho \) are identities, we say that \( \Bold M \) is a \textbf{strict monoidal category}.
\end{definition}

\begin{definition}\label{def:enriched_category}\cite{MacLane1994}[180],\cite{nLab:enriched_category}
  Enriched categories provide additional structure to the morphism sets of locally small categories. The definition can be compared with\cref{def:category}. We say that \( \Bold C \) is an \textbf{enriched category over the small monoidal category \( \Bold M \)} if
  \begin{itemize}
    \item there exists a class of objects, where the membership is denoted as \( A \in \Bold C \)
    \item for each object \( A \in \Bold C \), there exists an \textbf{identity morphism} \( j_A: 1 \to \Bold{C}(A, A) \)
    \item for each pair of objects \( A, B \in \Bold C \), there exists an object \( \Bold{C}(A, B) \) in \( \Bold M \)
    \item for each triple of objects \( A, B, C \in \Bold C \), there exists a \textbf{composition morphism} in \( \Bold M \):
    \begin{equation*}
      \circ_{A,B,C}: {\Bold C}(B, C) \times {\Bold C}(A, B) \to {\Bold C}(A, C).
    \end{equation*}
  \end{itemize}
  such that
  \begin{defenum}
    \item the following diagram commutes for all objects \( A, B, C, D \in \Bold C \)
    \begin{Center}
      \begin{tikzcd}
         \Bold{C}(A, D)                                                                                                               &                                                                                                           \\
         \Bold{C}(C, D) \otimes \Bold{C}(A, C) \arrow[u, "\circ_{A,C,D}"]                                                             & \Bold{C}(B, D) \otimes \Bold{C}(A, B) \arrow[lu, "\circ_{A,B,D}"']                                        \\
                                                                                                                                      &                                                                                                           \\
         \Bold{C}(C, D) \otimes (\Bold{C}(B, C) \otimes \Bold{C}(A, B)) \arrow[r, "\alpha"] \arrow[uu, "{\Id \otimes \circ_{A,B,C}}"] & (\Bold{C}(C, D) \otimes \Bold{C}(B, C)) \otimes \Bold{C}(A, B) \arrow[uu, "{\circ_{B,C,D} \otimes \Id}"']
      \end{tikzcd}
    \end{Center}

    \item the following diagram commutes for all objects \( A, B \in \Bold M \)

    \begin{Center}
      \begin{tikzcd}
         \Bold{C}(B, B) \otimes \Bold{C}(A, B) \arrow[rd, "\circ_{A,B,B}"] &                & \Bold{C}(A, B) \otimes \Bold{C}(A, A) \arrow[ld, "\circ_{A,A,B}"'] \\
                                                                           & \Bold{C}(A, B) &                                                                    \\
         1 \otimes \Bold{C}(A, B) \arrow[ru, "\lambda"] \arrow[uu, "j"]    &                & \Bold{C}(A, B) \times 1 \arrow[uu, "j"'] \arrow[lu, "\rho"]
      \end{tikzcd}
    \end{Center}
  \end{defenum}

  In order for monoidal categories to actually be categories (more specifically, locally small categories), formally we need a functor \( U: \Bold{M} \to \Bold{Set} \) so that morphism objects \( \Bold C(A, B) \) become sets \( U(\Bold C(A, B)) \). This is usually defined implicitly, for example \( U(\Bold C(A, B)) \coloneqq \Bold{M}(1, C(A, B)) \).
\end{definition}

\begin{definition}\label{def:preadditive_category}\cite{MacLane1994}[28]
  A \textbf{preadditive category \( \Bold C \)} is any category enriched over the category \( \Bold{Ab} \) of abelian groups\Tinyref{def:category_of_groups}, such that composition
  \begin{equation*}
    \circ_{A,B,C}: \Bold{Ab}(B, C) \times \Bold{Ab}(A, B) \to \Bold{Ab}(A, C)
  \end{equation*}
  is bilinear, e.g. given group homomorphisms \( f, f': A \to B \) and \( g, g': B \to C \), we have
  \begin{equation*}
    (g + g') \circ (f + f') = g \circ f + g \circ f' + g' \circ f + g' \circ f'.
  \end{equation*}
\end{definition}

\begin{definition}\label{def:zero_morphism}
  Let \( \Bold C \) be a category. We say that the morphism \( f: A \to B \) is
  \begin{defenum}
    \DItem{def:zero_morphism/left} a \textbf{left-zero morphism} or a \textbf{constant morphism} if \( f \circ g = f \circ h \) for any two morphisms \( g, h: A' \to A \) for any object \( A' \).
    \DItem{def:zero_morphism/right} a \textbf{right-zero morphism} or a \textbf{coconstant morphism} if \( g \circ f = h \circ f \) for any two morphisms \( g, h: B \to B' \) for any object \( B' \).
    \DItem{def:zero_morphism/bidirectional} a \textbf{zero morphism} if it is both a left-zero and a right-zero morphism. We denote it by \( 0_{A,B} \) if it is unique (for example, in preadditive categories\Tinyref{def:preadditive_category}).
  \end{defenum}
\end{definition}

\begin{proposition}\label{def:preadditive_zero_morphisms}
  If \( \Bold C \) is a preadditive category\Tinyref{def:preadditive_category} and \( A, B \in \Bold{C} \), the identity of \( \Bold{C}(A, B) \) is the unique zero morphism\Tinyref{def:zero_morphism} from \( A \) to \( B \).
\end{proposition}
\begin{proof}
  Denote the identity of \( \Bold{C}(A, B) \) by \( 0_{A,B} \). We will show that it is a zero morphism in the sense of \cref{def:zero_morphism}.

  Let \( C \in \Bold{C} \) and fix a morphism \( f: B \to C \). Then, by linearity,
  \begin{align*}
    f \circ 0_{A,B} + f \circ 0_{A,B}
    =
    f \circ (0_{A,B} + 0_{A,B})
    =
    f \circ 0_{A,B}.
  \end{align*}

  Thus \( f \circ 0_{A,B} = 0_{A,C} \). Since this holds for any function, we conclude that \( g \circ 0_{A,B} = h \circ 0_{A,B} = 0_{A,C} \) for any two morphisms in \( g, h \in \Bold{C}(B,C) \) and hence \( 0_{A,B} \) is a left zero morphism. The proof that \( 0_{A,B} \) is a right zero morphism is identical. Hence \( 0_{A,B} \) is a zero morphism.

  Now we will show that these are the only zero morphisms in \( \Bold{C} \). Assume that \( z: A \to B \) is a zero morphism. Then
  \begin{equation*}
    z = 0_{B,B} \circ z = (0_{B,B} + 0_{B,B}) \circ z = z + z,
  \end{equation*}
  hence \( z = 0_{A,B} \).
\end{proof}

\begin{proposition}\label{thm:preadditive_category_biproducts}
  If \( \Bold C \) is a preadditive category, the vertices of nonempty finite products and coproducts coincide.
\end{proposition}
\begin{proof}
  Let \( X: \Bold{I} \to \Bold{C} \) be a finite discrete diagram. Denote the objects \( X(i) \) by \( X_i \) and their product by
  \begin{equation*}
    (X, \pi) \coloneqq \varprojlim D
  \end{equation*}
  where \( X \) is an object in \( C \) and
  \begin{equation*}
    \pi = \{ \pi_i: X \to X_i \}_{i \in \Bold I}
  \end{equation*}
  is the family of projections.

  Consider the object \( X_i \in \Bold{C} \) with the family of morphisms
  \begin{align*}
    \begin{dcases}
      \begin{drcases}
        \Id_{X_i},   &j = i \\
        0_{X_i,X_j}, &j \neq i
      \end{drcases}
    \end{dcases}_{j \in \Bold I}
  \end{align*}

  By the definition of product\Tinyref{def:categorical_product}, there exists a unique map \( \iota_i \) such that the following diagram commutes
  \begin{Center}
    \begin{tikzcd}
      X_i \arrow[rd, "\Id_{X_i}"'] \arrow[rr, "\iota_i", dotted] & & X \arrow[ld, "\pi_i"] \\
      & X_i &
    \end{tikzcd}
    \begin{tikzcd}
      X_i \arrow[rd, "0_{X_i,X_j}"'] \arrow[rr, "\iota_i", dotted] & & X \arrow[ld, "\pi_i"] \\
      & X_j &
    \end{tikzcd}
  \end{Center}

  Define \( \iota \coloneqq \{ \iota_i \}_{i \in \Bold I} \). We will prove that \( (X, \iota) \) is a coproduct\Tinyref{def:categorical_coproduct}.

  Let \( \Gamma \in \Bold{C} \) be an arbitrary object such that there exists a family of morphisms
  \begin{equation*}
    \{ \gamma_i: X_i \to \Gamma \}_{i \in \Bold I}.
  \end{equation*}

  Define
  \begin{equation*}
    f \coloneqq \sum_{i \in I} (\gamma_i \circ \pi_i): X \to \Gamma.
  \end{equation*}

  Fix \( i \in \Bold{i} \). Now we show that the following diagrams commute:
  \begin{Center}
    \begin{tikzcd}
      \Gamma &                                                   & X \arrow[ll, "f"'] \\
             & X_i \arrow[lu, "\gamma_i"] \arrow[ru, "\iota_i"'] &
    \end{tikzcd}
  \end{Center}

  Indeed,
  \begin{align*}
    f \circ \iota_i
    =
    \left(\sum_{j \in \Bold{I}} \gamma_j \circ \pi_j \right) \circ \iota_i
    =
    \sum_{i \in \Bold{I}} (\gamma_j \circ (\pi_j \circ \iota_i))
    =
    \gamma_i \circ \Id_{X_i} + \sum_{\substack{j \in \Bold{I} \\ {j \neq i}}} \gamma_j \circ 0_{X_i,X_j}
    =
    \gamma_i.
  \end{align*}

  Note that the sum is well-defined since the indexing category \( \Bold{I} \) is finite.

  Now we will show that the morphism \( f \) is unique.

  First define
  \begin{equation*}
    g \coloneqq \sum_{j \in \Bold{I}} \iota_j \circ \pi_j: X \to X.
  \end{equation*}

  Note that for each \( i \in \Bold{I} \),
  \begin{align*}
    \pi_i \circ g
    =
    \pi_i \circ \left( \sum_{j \in \Bold{I}} \iota_j \circ \pi_j \right)
    =
    \sum_{j \in \Bold{I}} ((\pi_i \circ \iota_j) \circ \pi_j)
    =
    \Id_i \circ \pi_i + \sum_{\substack{j \in \Bold{I} \\ {j \neq i}}} 0_{X,X_j}
    =
    \pi_i.
  \end{align*}

  We claim that \( g = \Id_X \). Since \( X \) is a product, there exists a unique morphism such that the following diagram commutes for each \( i \in \Bold{I} \):
  \begin{equation}\label{thm:preadditive_biproducts/product_identity}
    \begin{tikzcd}[baseline=(current bounding box.center)]
      X \arrow[rd, "\pi_i \circ g"'] \arrow[rr, "", dotted] & & X \arrow[ld, "\pi_i"] \\
      & X_i &
    \end{tikzcd}
  \end{equation}

  Both \( g \) and \( \Id_X \) satisfy the universal property in \cref{thm:preadditive_biproducts/product_identity}, hence they are equal.

  To show that the morphism \( f \) is unique, assume that there exists \( f': \Gamma \to X \) such that for each \( i \in \Bold{I} \),
  \begin{equation*}
    f' \circ \iota_i = \gamma_i.
  \end{equation*}

  But
  \begin{align*}
    f - f'
    =
    (f - f') \circ \Id_X
    =
    (f - f') \circ \left( \sum_{i \in \Bold{I}} \iota_i \circ \pi_i \right)
    =
    \sum_{i \in \Bold{I}} ((f \circ \iota_i) \circ \pi_i - (f' \circ \iota_i) \circ \pi_i)
    = \\ =
    \sum_{i \in \Bold{I}} (\gamma_i \circ \pi_i - \gamma_i \circ \pi_i)
    =
    0_{\Gamma,X},
  \end{align*}
  thus \( f = f' \).

  Hence the definition of coproduct is satisfied by \( (X, \iota) \).
\end{proof}

\begin{definition}\label{def:categorical_biproduct}
  Let \( \Bold C \) be a preadditive category. A \textbf{biproduct} of the finite family \( \{ X_i \}_{i \in I} \) of objects in \( \Bold{C} \) is a triple \( (X, \pi, \iota) \), such that \( (X, \pi) \) is a product, \( (X, \iota) \) is a coproduct.
\end{definition}

\begin{note}\label{note:preadditive_category_biproducts}
  By \cref{thm:preadditive_category_biproducts}, if a nonempty finite product exists in a preadditive category, so does the corresponding coproduct, hence it is a biproduct. If the empty product exists, however, it may not be a coproduct.

  In order to ensure some regularity, additive categories\Tinyref{def:additive_category} are introduced.
\end{note}

\begin{definition}\label{def:additive_category}\cite{MacLane1994}[196]
  A preadditive category\Tinyref{def:preadditive_category} is called additive if it has all finite biproducts\Tinyref{def:categorical_biproduct}, including empty biproducts (see \cref{thm:additive_category_biproducts}).
\end{definition}

\begin{theorem}\label{thm:additive_category_biproducts}
  If \( \Bold C \) is an additive category, the vertices of finite products and coproducts coincide, that is, they are biproducts.
\end{theorem}
\begin{proof}
  The proof follows from \cref{thm:preadditive_category_biproducts} and the fact that the initial\Tinyref{note:empty_categorical_coproduct} and terminal\Tinyref{note:empty_categorical_product} object coincide.
\end{proof}

\begin{definition}\label{def:categorical_kernel}
  Let \( \Bold C \) be a preadditive category and \( f: A \to B \) be a morphism in \( \Bold C \). We define the \textbf{kernel} \( \ker(f) \) of \( f \) as the equalizer\Tinyref{def:categorical_equalizer} of \( f \) and \( 0_{A,B} \). Thus \( \ker(f) \) is a morphism from \( L \) (the limit vertex) to \( A \).

  Analogously, we define the \textbf{cokernel} \( \Coker(f) \) of \( f \) as the coequalizer\Tinyref{def:categorical_coequalizer} of \( f \) and \( 0_{A,B} \). Thus \( \Coker(f): B \to C \), where \( C \) is the colimit vertex.
\end{definition}

\begin{definition}\label{def:abelian_category}\cite{MacLane1994}[196]
  An additive category\Tinyref{def:additive_category} \( \Bold C \) is called an \textbf{abelian category} if:
  \begin{defenum}
    \item \( \Bold C \) has a kernel and a cokernel for every morphism\Tinyref{def:categorical_kernel}
    \item every monomorphism is a kernel and every epimorphism is a cokernel\Tinyref{def:morphism_invertibility}
  \end{defenum}
\end{definition}

\begin{proposition}\label{def:abelian_category_morphism_factorization}\cite{MacLane1994}[proposition 8.3.1]
  In an abelian category \( \Bold C \), every morphism \( f: A \to B \) has a factorization \( f = \Img f \circ \Coimg f \), where
  \begin{itemize}
    \item \( \Img f \coloneqq \ker(\Coker f: B \to C_1): L_1 \to B \) is a monomorphism
    \item \( \Coimg f \coloneqq \Coker(\ker f: L_2 \to A): A \to C_2 \) is an epimorphism
  \end{itemize}
  Here \( L_1 \) and \( L_2 \) are the limit vertices and \( C_1 \) and \( C_2 \) are the colimit vertices as in~\cref{def:categorical_kernel}. Necessarily \( L_1 \cong C_2 \).
\end{proposition}

\begin{definition}\label{def:exact_morphism_pair}\cite{MacLane1994}[196]
  In an abelian category \( \Bold C \), a composable pair of morphisms \( f: A \to B \) and \( g: B \to C \) is said to be \textbf{exact at \( B \)} if \( \Img f \equiv \ker g \) as subobjects of \( B \) (or, equivalently, \( \Coker f \equiv \Coimg g \); see \cref{def:categorical_subobject}).
\end{definition}

\begin{definition}\label{def:short_exact_sequence}\cite{MacLane1994}[196]
  In an abelian category \( \Bold C \), the tower diagram\Tinyref{def:tower_diagram}
  \begin{equation}\label{def:short_exact_sequence/diagram}
    \begin{tikzcd}[baseline=(current bounding box.center)]
      0 \arrow[r, "\iota"] & A \arrow[r, "i"] & B \arrow[r, "p"] & C \arrow[r, "\pi"] & 0
    \end{tikzcd}
  \end{equation}
  is called a \textbf{short exact sequence (SES)} if it is exact at \( A \), \( B \) and \( C \) (in the sense of~\cref{def:exact_morphism_pair}).

  Equivalently, \cref{def:short_exact_sequence/diagram} is short exact if and only if \( f \equiv \ker g \) as subobjects of \( B \) and \( g \equiv \Coker f \) as subobjects of \( C \).
\end{definition}

\begin{note}\label{note:short_exact_sequence_factorization}
  Since \( 0 \) is an initial object, the morphism \( \iota: 0 \to A \) exists and is unique. Analogously, \( \pi: C \to 0 \) exists and is unique. This is why \( \iota \) and \( \pi \) can be skipped entirely when defining short exact sequences.

  The morphism \( i \) is necessarily a monomorphism (\enquote{i} stands for \enquote{injection}) since it is equivalent to a kernel and \( p \) is necessarily an epimorphism (\enquote{p} stands for \enquote{projection}). When either \( i \) or \( p \) is obvious, they may also be skipped.

  This makes SES a good framework for describing factorization of algebraic structures, as can be seen in~\cref{ex:short_exact_sequences}.
\end{note}

\begin{definition}\label{def:exact_sequence_morphisms}\cite{MacLane1994}[198]
  Consider the two short exact sequences over the same category \( \Bold C \):
  \begin{Center}
    \begin{tikzcd}
      0 \arrow[r] & A \arrow[r, "i"]   & B \arrow[r, "p"]   & C \arrow[r]  & 0 \\
      0 \arrow[r] & A' \arrow[r, "i'"] & B' \arrow[r, "p'"] & C' \arrow[r] & 0
    \end{tikzcd}
  \end{Center}
  We say that the triple \( f = (f_A: A \to A', f_B: B \to B', f_C: C \to C') \) is a \textbf{morphism of the short exact sequences} if the following diagram commutes:
  \begin{Center}
    \begin{tikzcd}
      0 \arrow[r] & A \arrow[r, "i"] \arrow[d, "f_A"] & B \arrow[r, "p"] \arrow[d, "f_B"] & C \arrow[r] \arrow[d, "f_C"] & 0 \\
      0 \arrow[r] & A' \arrow[r, "i'"]                & B' \arrow[r, "p'"]                & C' \arrow[r]                 & 0
    \end{tikzcd}
  \end{Center}

  If each component of \( f \) is an isomorphism, we say that the short exact sequences are \textbf{isomorphic}.
\end{definition}

\begin{definition}\label{def:split_exact_sequence}\cite{nLab:split_exact_sequence}
  A short exact sequence
  \begin{equation}\label{def:split_exact_sequence/short_diagram}
    \begin{tikzcd}[baseline=(current bounding box.center)]
      0 \arrow[r] & A \arrow[r, "i"] & B \arrow[r, "p"] & C \arrow[r] & 0
    \end{tikzcd}
  \end{equation}
  is said to be \textbf{splitting} or \textbf{split exact} if any of the following equivalent conditions hold:
  \begin{defenum}
    \item \( i \) has a left inverse
    \item \( p \) has a right inverse
    \item the sequence~\cref{def:split_exact_sequence/short_diagram} is isomorphic to the SES
    \begin{equation}\label{def:short_exact_sequence/split_diagram}
      \begin{tikzcd}[baseline=(current bounding box.center)]
        0 \arrow[r] & A \arrow[r] & A \otimes C \arrow[r] & C \arrow[r] & 0
      \end{tikzcd}
    \end{equation}
    with the canonical injection and projection morphisms
  \end{defenum}

  The equivalence of the three conditions is called the \textbf{splitting lemma}.
\end{definition}

\begin{example}\label{ex:short_exact_sequences}
  \mbox{}
  \begin{defenum}
    \DItem{ex:short_exact_sequences/cyclic_groups} Fix a natural number \( n > 0 \) and consider the category of \( \Bold{Ab} \) of abelian groups and the following short exact sequence:
    \begin{Center}
      \begin{tikzcd}
        0 \arrow[r] & \BB{Z} \arrow[r, "n \cdot"] & \BB{Z} \arrow[r, "\lbrack \cdot \rbrack_n"] & \BB{Z} / n \BB{Z} \arrow[r] & 0
      \end{tikzcd}
    \end{Center}
    where
    \begin{itemize}
      \item \( i(x) \coloneqq nx \) multiplies any integer by \( n \) to obtain the subgroup \( n \BB{Z} \)
      \item \( p(x) \coloneqq [x]_n \) projects any integer into the corresponding remainder when divided by \( n \)
    \end{itemize}

    The (group-theoretic) image \( n \BB{Z} \) of \( i \) is precisely the (group-theoretic) kernel of \( [\cdot]_n \). The sequence does not split since \( i \) does not have a left inverse.

    \DItem{ex:short_exact_sequences/real_number_splitting} Consider the additive groups \( \BB{Z} \), \( \BB{R} \) and the unit circle group \( S_{\BB{R}^2} \) with the group operation given by addition of polar angles and with the vector \( (1, 0)^T \) as a unit.
    \begin{Center}
      \begin{tikzcd}
        0 \arrow[r] & \BB{Z} \arrow[r, "i"] & \BB{R} \arrow[r, "p"] & S_{\BB{R}^2} \arrow[r] & 0
      \end{tikzcd}
    \end{Center}
    where
    \begin{itemize}
      \item \( i \) is the canonical embedding of \( \BB{Z} \) is \( \BB{R} \)
      \item \( p \coloneqq f \circ g \) where \( g(x) \coloneqq \{ x \} \) is the fractional part of \( x \) (modulo 1) and \( f(x) \coloneqq (\cos(x), \sin(x))^T \) is an embedding of the interval \( [0, 1) \) into the unit circle.
    \end{itemize}

    Since each integer has fractional part \( 0 \) and \( p(0) = (1, 0)^T \), the image \( \Bold Z \) of \( \Bold Z \) under \( i \) is the kernel of the group homomorphism \( p \).

    The sequence does not split since \( i \) is not left-invertible.

    \DItem{ex:short_exact_sequences/vector_space_sum} The following SES of real vector spaces splits
    \begin{Center}
      \begin{tikzcd}[ampersand replacement=\&]
        0 \arrow[r] \& \BB{R} \arrow[r, "{\begin{pmatrix}1 \\ 0\end{pmatrix}}"] \& \BB{R}^2 \arrow[r, "{\begin{pmatrix}0 & 1\end{pmatrix}}"] \& \BB{R} \arrow[r] \& 0
      \end{tikzcd}
    \end{Center}
    since all of the following equivalent conditions hold
    \begin{itemize}
      \item \( \begin{pmatrix}1 & 0\end{pmatrix} \) is a left inverse to \( \begin{pmatrix}1 \\ 0\end{pmatrix} \)
      \item \( \begin{pmatrix}0 \\ 1\end{pmatrix} \) is a right inverse to \( \begin{pmatrix}0 & 1\end{pmatrix} \)
      \item \( \BB{R}^2 \) is a direct product and a biproduct of two copies of \( \BB{R} \)
    \end{itemize}

    \DItem{ex:short_exact_sequences/fundamental_theorem_of_calculus} The fundamental theorem of calculus is a splitting of the SES of vector spaces
    \begin{Center}
      \begin{tikzcd}
        0 \arrow[r] & \BB{R} \arrow[r] & C^n(\BB{R}, \BB{R}) \arrow[r, "\frac d {dx}"] & C^{n-1}(\BB{R}, \BB{R}) \arrow[r] & 0.
      \end{tikzcd}
    \end{Center}
  \end{defenum}
\end{example}

\begin{definition}\label{def:chain_complex}\cite{nLab:chain_complex}
  In an abelian category \( \Bold{C} \), the tower diagram\Tinyref{def:tower_diagram} with objects \( \{ C_n \}_{n \in \BB{Z}} \) and morphisms \( \partial_n: C_n \to C_{n-1} \)
  \begin{equation}\label{def:chain_complex/chain_diagram}
    \begin{tikzcd}[baseline=(current bounding box.center)]
      \ldots \arrow[r, "\partial_2"] & C_1 \arrow[r, "\partial_1"] & C_0 \arrow[r, "\partial_0"] & C_{-1} \arrow[r, "\partial_{-1}"] & \ldots
    \end{tikzcd}
  \end{equation}
  is called a \textbf{chain complex} if for every \( n \),
  \begin{equation*}
    \partial_n \circ \partial_{n+1} = 0_{C_{n+1},C_{n-1}}.
  \end{equation*}

  Chain complexes may be finite or infinite in one or both directions. The morphisms \( \partial_n \) are called \textbf{boundary maps}.

  A \textbf{cochain complex} is a chain complex on \( \Bold{C}^{\Op} \), i.e.
  \begin{equation}\label{def:chain_complex/cochain_diagram}
    \begin{tikzcd}[baseline=(current bounding box.center)]
      \ldots & C_1 \arrow[l, "\partial_1"'] & C_0 \arrow[l, "\partial_0"'] & C_{-1} \arrow[l, "\partial_{-1}"'] & \ldots \arrow[l, "\partial_{-2}"']
    \end{tikzcd}
  \end{equation}
  such that for any \( n \),
  \begin{equation*}
    \partial_{n+1} \circ \partial_n = 0_{C_{n-1},C_{n+1}}.
  \end{equation*}
\end{definition}
