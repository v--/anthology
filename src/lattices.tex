\subsection{Lattices}\label{subsec:lattices}

\begin{remark}\label{remark:infinite_join_meet}
  Suprema and infima in posets can be used to define operations named \Def{joins} and \Def{meets}\Tinyref{def:join_meet}, however there are also axioms for binary joins and \hyperref[def:binary_join_meet]{meets}. If we are interested in infinitary joins and meets, however, we need to use the poset definition. This can be accomplished indirectly by
  \begin{enumerate}
    \item defining joins and meets axiomatically
    \item using them to define a partial order
    \item using the partial order to define infinitary joins and meets
  \end{enumerate}
\end{remark}

\begin{definition}\label{def:binary_join_meet}
  Fix an arbitrary set \( X \) and let \( x, y \in X \). Define two binary operations
  \begin{itemize}
    \item the \Def{join} of \( x \) and \( y \), \( x \vee y \)
    \item the \Def{meet} of \( x \) and \( y \), \( x \wedge y \)
  \end{itemize}
  such that,
  \begin{defenum}
    \DItem{def:binary_join_meet/associativity}(associativity)
    \begin{align*}
      (x \vee y) \vee z = x \vee (y \vee z)
      &&
      (x \wedge y) \wedge z = x \wedge (y \wedge z).
    \end{align*}

    \DItem{def:binary_join_meet/commutativity}(commutativity)
    \begin{align*}
      x \vee y = y \vee x
      &&
      x \wedge y = y \wedge x.
    \end{align*}

    \DItem{def:binary_join_meet/absorption}(absorption)
    \begin{align*}
      x \vee (y \wedge x) = x
      &&
      x \wedge (y \vee x) = x.
    \end{align*}
  \end{defenum}

  We can use joins to define the partial order \hyperref[def:poset]{relation}
  \begin{equation*}
    x \leq y \iff x \vee y = y,
  \end{equation*}
  thus \( X \) is automatically a poset and this structure is compatible with \fullref{def:join_meet}.
\end{definition}
\begin{proof}
  We will prove that \( \leq \) is indeed a partial order.
  \begin{description}
    \RItem{def:binary_relation/reflexive} Direct consequence of \fullref{thm:binary_join_meet_properties/idempotence}.
    \RItem{def:binary_relation/antisymmetric} Let \( x \leq y \) and \( y \leq x \), that is, \( x \vee y = y \) and \( y \vee x = x \). By \fullref{def:binary_join_meet/commutativity}, \( x = y \vee x = x \vee y = y \).
    \RItem{def:binary_relation/transitive} Let \( x \leq y \) and \( y \leq z \), that is, \( x \vee y = y \) and \( y \vee z = z \). Then, by \fullref{def:binary_join_meet/associativity},
    \begin{equation*}
      z = y \vee z = (x \vee y) \vee z = x \vee (y \vee z) = x \vee z.
    \end{equation*}
  \end{description}
\end{proof}

\begin{remark}\label{remark:binary_join_meet_order}
  We can analogously define \( x \leq y \iff x \wedge y = x \). The resulting partial order would be the same.
\end{remark}

\begin{proposition}\label{thm:binary_join_meet_properties}
  If \( (X, \vee, \wedge) \) is a set with a binary join and a \hyperref[def:binary_join_meet]{meet}, the following properties hold:
  \begin{defenum}
    \DItem{thm:binary_join_meet_properties/idempotence} both operations are \Def{idempotent}, i.e. \( x \vee x = x = x \wedge x \)
  \end{defenum}
\end{proposition}
\begin{proof}\mbox{}
  \begin{description}
    \RItem{thm:binary_join_meet_properties/idempotence} \fullref{def:binary_join_meet/absorption} implies that
    \begin{equation*}
      x \vee x = x \vee (x \wedge (x \vee x)) = x
    \end{equation*}
    and analogously \( x \wedge x = x \).
  \end{description}
\end{proof}

\begin{definition}\label{def:join_meet}
  Let \( (X, \leq) \) be a \hyperref[def:poset]{poset}. We define \Def{joins} \( \vee \) and \Def{meets} \( \wedge \) as the \hyperref[def:function/partial]{partial} functions
  \begin{align*}
    &\vee: \Pow(X) \to X
    &&\wedge: \Pow(X) \to X
    \\
    &\vee(A) \coloneqq \sup X
    &&\wedge(A) \coloneqq \inf X.
  \end{align*}

  For finite sets, we usually use the infix notation \( x_1 \vee \ldots \vee x_n \) instead of \( \vee \{ x_1, \ldots, x_n \} \).
\end{definition}
\begin{proof}
  We first show that \( \vee \) and \( \wedge \) satisfy \fullref{def:binary_join_meet}. Since suprema and infima are obviously associative and commutative, it remains only to show \fullref{def:binary_join_meet/absorption}, that is, for any comparable \( x, y \in X \),
  \begin{align*}
    x = \sup \{x, \inf \{ x, y \} \}
    &&
    x = \inf \{x, \sup \{ x, y \} \}.
  \end{align*}

  If \( x \leq y \), then
  \begin{align*}
    \sup \{ x, \inf \{ x, y \} \} = \sup \{ x, x \} = x
    &&
    \inf \{ x, \sup \{ x, y \} \} = \inf \{ x, y \} = x.
  \end{align*}

  If \( y \leq x \), then
  \begin{align*}
    \sup \{ x, \inf \{ x, y \} \} = \sup \{ x, y \} = x
    &&
    \inf \{ x, \sup \{ x, y \} \} = \inf \{ x, x \} = x.
  \end{align*}

  We now show that if the partial order \( \leq \) was defined using binary joins and meets as in \fullref{def:binary_join_meet}, then the original join \( \vee \) and meet \( \wedge \) are compatible with the binary \( \sup \) and \( \inf \).

  Fix \( x, y \in X \). Since the functions \( \vee \) and \( \wedge \) are total, all binary suprema and infima exist. If \( \sup \{ x, y \} = z \), then \( z \) is the least element such that both \( x \leq z \) and \( y \leq z \). Thus
  \begin{equation*}
    x \vee z = z = y \vee z.
  \end{equation*}

  Hence
  \begin{equation*}
    x \vee y = (x \vee (z \wedge x)) \vee y = x \vee z \vee y = x \vee (z \vee z) \vee y = \\ = (x \vee z) \vee (z \vee y) = z \vee z = z.
  \end{equation*}

  Conversely, if \( x \vee y = z \), by \fullref{def:binary_join_meet/absorption},
  \begin{equation*}
    x \vee z = (x \wedge (y \vee x)) \vee z = (x \wedge z) \vee z = z,
  \end{equation*}
  thus \( x \leq z \). Analogously, \( y \leq z \).

  If we assume that there exists \( t \in X \) such that \( x \leq t \leq z \) and \( y \leq t \leq z \), then
  \begin{equation*}
    t = t \vee x = t \vee x \vee y = t \vee z = z.
  \end{equation*}

  Thus \( z = \sup \{ x, y \} \).

  The equivalence between binary \( \inf \) and \( \wedge \) can be obtained analogously.
\end{proof}

\begin{definition}\label{def:lattice}
  A poset \( (X, \leq) \) is called a \Def{lattice} if it has
  \begin{defenum}
    \DItem{def:lattice/top}(top) a \Def{top element} \( \top \), such that \( \top = \vee X \) (in particular, \( \vee X \) exists).
    \DItem{def:lattice/bottom}(bottom) a \Def{bottom element} \( \bot \), such that \( \bot = \wedge X \).
    \DItem{def:lattice/join}(finite joins) all finite \hyperref[def:binary_join_meet]{joins} exist.
    \DItem{def:lattice/meet}(finite meets) all finite \hyperref[def:binary_join_meet]{meets} exist.
  \end{defenum}

  If the join and meet are defined axiomatically, all finite joins and meets necessarily exist.

  If the last two properties hold for all joins and meets, not necessarily finite, we say that the lattice is a \Def{full lattice}.
\end{definition}

\begin{proposition}\label{thm:lattice_homomorphism}
  A \hyperref[def:first_order_homomorphism]{homomorphism} of the lattices
  \begin{equation*}
    (X, \top_X, \bot_X, \vee_X, \wedge_X)
  \end{equation*}
  and
  \begin{equation*}
    (Y, \top_Y, \bot_Y, \vee_Y, \wedge_Y)
  \end{equation*}
  is a function \( \varphi: X \to Y \) such that
  \begin{itemize}
    \item \( f(a \vee_X b) = f(a) \vee_Y f(b) \)
    \item \( f(a \wedge_X b) = f(a) \wedge_Y f(b) \)
    \item \( f(\bot_X) = \bot_Y \)
    \item \( f(\bot_X) = \bot_Y \)
  \end{itemize}

  That is, no axioms follow automatically as in \fullref{thm:group_homomorphism_single_condition}.

  For Boolean \hyperref[def:boolean_algebra]{algebras}, however, complements are automatically preserved.
\end{proposition}

\begin{remark}\label{def:lattice_categorical_product}
  The existence of finite joins and meets is equivalent to the existence of finite products and coproducts in the corresponding category by \fullref{thm:partial_order_category_correspondence}.
\end{remark}

\begin{definition}\label{def:distributive_lattice}\cite{nLab:distributive_lattice}
  A lattice \( (X, \top, \bot, \vee, \wedge) \) is called a \Def{distributive lattice} if any of the following two equivalent distributive axioms hold for any \hyperref[def:indexed_family]{family} \( \{ x_\al \}_{\al \in \CA} \subseteq X \) and any \( y \in X \):
  \begin{description}
    \DItem{def:distributive_lattice/distributivity}(distributivity)
    \begin{align*}
      y \wedge \left( \bigvee_{\al \in \CA} x_\al \right) = \bigwedge_{\al \in \CA} (y \vee x_\al)
      &&
      y \vee \left( \bigwedge_{\al \in \CA} x_\al \right) = \bigvee_{\al \in \CA} (y \wedge x_\al).
    \end{align*}
  \end{description}
\end{definition}

\begin{definition}\label{def:boolean_algebra}\cite{nLab:boolean_algebra}
  Let \( X \) be a distributive lattice. A \Def{complement} of \( x \) is an element \( y \) of \( X \) such that
  \begin{align*}
    x \vee y = \top, && x \wedge y = \bot.
  \end{align*}

  Since in a distributive lattice complements are \hyperref[thm:boolean_algebra_properties/unique_complement]{unique}, the complement of \( x \) is denoted by \( \Ol x \). If all elements of \( X \) have complements, then \( (X, \top, \bot, \vee, \wedge, \Ol \cdot) \) is called a \Def{Boolean algebra}.
\end{definition}

\begin{example}\label{ex:boolean_algebras}
  Examples of Boolean \hyperref[def:boolean_algebra]{algebras} include:

  \begin{itemize}
    \item The equivalence classes of propositional formulas under semantic equivalence (see \fullref{thm:propositional_logic_boolean_algebra}).
    \item The Galois field \( \BF_2 \) with suitably defined operations (see \fullref{thm:f2_is_boolean_algebra}).
    \item The power set of any set, usually taken to be a space with additional structure (see \fullref{thm:subsets_form_boolean_algebra}).
  \end{itemize}
\end{example}

\begin{proposition}\label{thm:boolean_algebra_properties}
  A Boolean algebra \( X \) has the following basic properties:
  \begin{propenum}
    \DItem{thm:boolean_algebra_properties/unique_complement} For each \( x \in X \), there exists a unique complement \( \Ol x \).
    \DItem{thm:boolean_algebra_properties/double_complement} For each \( x \in X \), we have \( x = \Ol{\Ol x} \).
  \end{propenum}
\end{proposition}
\begin{proof}\mbox{}
  \begin{itemize}
    \RItem{thm:boolean_algebra_properties/unique_complement} If \( y \) and \( z \) are both complements of \( x \), then
    \begin{align*}
      y
      =
      y \wedge \top
      =
      y \wedge (z \vee x)
      =
      (y \wedge z) \vee (y \wedge x)
      = \\ =
      y \wedge z
      =
      (x \wedge z) \vee (y \wedge z)
      =
      (x \vee y) \wedge z
      =
      z.
    \end{align*}

    \RItem{thm:boolean_algebra_properties/double_complement} Fix \( x \in X \). We have
    \begin{align*}
      \Ol{\Ol x}
      =
      \Ol{\Ol x} \wedge \top
      =
      \Ol{\Ol x} \wedge (\Ol x \vee x)
      =
      (\Ol{\Ol x} \wedge \Ol x) \vee (\Ol{\Ol x} \wedge x)
      = \\ =
      \Ol{\Ol x} \wedge x
      =
      (\Ol{\Ol x} \wedge x) \vee (\Ol x \wedge x)
      =
      (\Ol{\Ol x} \vee \Ol x) \wedge x
      =
      x.
    \end{align*}
  \end{itemize}
\end{proof}

\begin{theorem}[De Morgan's laws]\label{thm:de_morgans_laws}
  If \( X \) is a Boolean \hyperref[def:boolean_algebra]{algebra}, the following hold for any \hyperref[def:indexed_family]{family} \( \{ x_\al \}_{\al \in \CA} \subseteq X \):
  \begin{align*}
    \Ol{\bigvee_{\al \in \CA} x_\al} = \bigwedge_{\al \in \CA} \Ol{x_\al}
    &&
    \Ol{\bigwedge_{\al \in \CA} x_\al} = \bigvee_{\al \in \CA} \Ol{x_\al}
  \end{align*}
\end{theorem}
\begin{proof}
  We will first show
  \begin{equation}\label{thm:de_morgans_laws/equation}
    \Ol{\bigvee_{\al \in \CA} x_\al} = \bigwedge_{\al \in \CA} \Ol{x_\al}
  \end{equation}

  In order for \( \wedge_{\al \in \CA} \Ol{x_\al} \) to be the complement of \( \vee_{\al \in \CA} x_\al \), the equations in \fullref{def:boolean_algebra} need to be satisfied.

  By distributivity,
  \begin{align*}
    \left( \bigwedge_{\al \in \CA} \Ol{x_\al} \right) \vee \left( \bigvee_{\beta \in \CA} x_\beta \right)
    &=
    \bigvee_{\al \in \CA} \left( \Ol{x_\al} \wedge \bigvee_{\beta \in \CA} x_\beta \right)
    = \\ &=
    \bigvee_{\al \in \CA} \bigwedge_{\beta \in \CA} (\Ol{x_\al} \vee x_\beta)
    = \\ &=
    \bigvee_{\al \in \CA} \left( (\Ol{x_\al} \vee x_\al) \wedge \bigwedge_{\substack{\beta \in \CA \\ \beta \neq \al}} (\Ol{x_\al} \vee x_\beta) \right)
    = \\ &=
    \bigvee_{\al \in \CA} \left( \top \wedge \bigwedge_{\substack{\beta \in \CA \\ \beta \neq \al}} (\Ol{x_\al} \vee x_\beta) \right)
    = \\ &=
    \left( \bigwedge_{\al \in \CA} \top \right) \vee \bigvee_{\al \in \CA} \left( \bigvee_{\substack{\beta \in \CA \\ \beta \neq \al}} (\Ol{x_\al} \vee x_\beta) \right)
    = \\ &=
    \top.
  \end{align*}

  Analogously,
  \begin{equation*}
    \left( \bigwedge_{\al \in \CA} \Ol{x_\al} \right) \wedge \left( \bigvee_{\beta \in \CA} x_\beta \right) = \bot.
  \end{equation*}

  This proves \fullref{thm:de_morgans_laws/equation}.

  The other law follows from this one by double \hyperref[thm:boolean_algebra_properties]{negation}:
  \begin{equation*}
    \Ol{\bigwedge_{\al \in \CA} x_\al}
    =
    \Ol{\bigwedge_{\al \in \CA} \Ol{\Ol{x_\al}}}
    =
    \Ol{\Ol{\bigvee_{\al \in \CA} \Ol{x_\al}}}
    =
    \bigvee_{\al \in \CA} \Ol{x_\al}.
  \end{equation*}
\end{proof}

\begin{proposition}\label{thm:binary_boolean_algebras_are_isomorphic}
  All two-element Boolean \hyperref[def:boolean_algebra]{algebras} are isomorphic.
\end{proposition}
\begin{proof}
  We will show that the Boolean algebra
  \begin{align*}
    &\left( \{ \top, \bot \}, \top, \bot, \vee, \wedge, \Ol \cdot \right)
  \end{align*}
  is isomorphic to the Galois \hyperref[thm:galois_field_existence]{field} \( \BF_2 \) with the Boolean algebra structure defined in \fullref{thm:f2_is_boolean_algebra}.

  There is an obvious bijection
  \begin{equation*}
    \varphi(x) \coloneqq \begin{cases}
      1, &x = \top \\
      0, &x = \bot
    \end{cases}.
  \end{equation*}

  We only need to verify that \( \varphi \) preserves meets and joints. But this is trivial:
  \begin{align*}
    \varphi(x \vee y)
    &=
    \begin{rcases}
      \begin{cases}
        0, &x = y = 0 \\
        1, &\text{otherwise}
      \end{cases}
    \end{rcases}
    =
    x \oplus y \oplus (x \odot y).
    \\
    \varphi(x \wedge y)
    &=
    \begin{rcases}
      \begin{cases}
        1, &x = y = 1 \\
        0, &\text{otherwise}
      \end{cases}
    \end{rcases}
    =
    x \odot y.
  \end{align*}
\end{proof}
