\subsection{Functors}\label{subsec:functors}

\begin{definition}\label{def:functor}\cite[definitions 1.2.1, 1.2.10]{Leinster2014}
  Let \( \Bold A \) and \( \Bold B \) be categories. A \Def{(covariant) functor} \( F: \Bold A \to \Bold B \) consists of:
  \begin{itemize}
    \item a function \( \Bold A \to \Bold B \), written as \( A \mapsto F(A) \).
    \item for each \( A, A' \in \Bold A \), a function
    \begin{equation*}
      \Cat{A}(A, A') \to \Bold{B}(F(A), F(A')),
    \end{equation*}
    written as \( f \mapsto F(f) \).
  \end{itemize}
  such that
  \begin{defenum}
    \DItem{def:functor/composition_axiom} \( A \overset f \mapsto B \overset g \mapsto C \) implies \( F(g \circ f) = F(g) \circ F(f) \).
    \DItem{def:functor/identity_axiom} \( A \in \Bold A \) implies \( F(\Id_A) = \Id_{F(A)} \).
  \end{defenum}

  If we replace the axiom~\cref{def:functor/composition_axiom} with
  \begin{defenum}
    \item[b')]\label{def:functor/contravariant_composition_axiom} \( A \overset f \mapsto B \overset g \mapsto C \) implies \( F(g \circ f) = F(f) \circ F(g) \),
  \end{defenum}
  we call \( F \) a \Def{contravariant functor}. Equivalently, \( F: \Bold A \to \Bold B \) is contravariant if and only if \( F: \Cat{A}^{-1} \to \Bold B \) is covariant.

  The \Def{identity functor} \( \Id_A: \Bold A \to \Bold A \) simply maps a category to itself.
\end{definition}

\begin{remark}\label{remark:image_of_functor_maybe_not_subcategory}
  The \Def{image} \( F(\Bold A) \) of a category \( \Bold A \) under a functor \( F: \Bold A \to \Bold B \) may not be a subcategory of \( \Bold B \). A simple example is can be constructed as follows:

  Let \( \Bold A \) be a category with four objects \( A, B, C, D \) and two morphisms \( f: A \to B \) and \( g: C \to D \). If \( F(B) = F(C) \), then \( F(f): F(A) \to F(B) \) and \( F(g): F(B) \to F(D) \), however there is no morphism from \( F(A) \) to \( F(D) \). Thus the image \( F(\Bold A) \) is not itself category.
\end{remark}

\begin{definition}\label{def:categorical_diagram}
  A generalization of set-indexed families\Tinyref{def:indexed_family} is given by diagrams. We fix a category \( \Bold I \), called an \Def{index category}, which is often assumed to be small. A \Def{diagram of shape \( \Bold I \)} is then any functor \( D: \Bold I \to \Bold A \), where \( \Bold A \) is any other category.

  It is often convenient to think of diagrams in terms of their images \( D(\Bold I) \), which are selections of objects and morphisms in \( \Bold A \). Note the image \( D(\Bold I) \) may not be a subcategory of \( \Bold A \)\Tinyref{remark:image_of_functor_maybe_not_subcategory}.

  If the category \( \Bold I \) is small, we say that the diagram is a \Def{small diagram}.
\end{definition}

\begin{example}\label{ex:categorical_diagrams}
  \mbox{}
  \begin{defenum}
    \item In the case when \( \Bold I \) is a small discrete category, a diagram \( D: \Bold I \to \Bold A \) is simply a mapping of each element \( i \) of \( \Bold I \) into an element of \( \Bold A \), i.e. we can interpret any diagram of shape \( \Bold I \) as a set-indexed family \( \{ A_i \}_{i \in I} \), where all \( A_i \) are objects in \( \Bold A \).

    \item If \( \Bold I \) is not discrete, a diagram \( D: \Bold I \to \Bold A \) also involves morphisms. For example, if \( \Bold I \) is a three-object category with two morphisms as in the following picture
    \begin{equation*}
      \bullet \longrightarrow \bullet \longrightarrow \bullet,
    \end{equation*}
    we can interpret a diagram \( D \) of shape \( \Bold I \) as a selection of objects and morphisms in \( \Bold A \) that satisfy the same relations as in \( \Bold I \):
    \begin{equation*}
      A
      \overset f \longrightarrow
      B
      \overset g \longrightarrow
      C.
    \end{equation*}
  \end{defenum}
\end{example}

\begin{definition}\label{def:tower_diagram}
  Let \( N \) be a subset of \( \Z \) and let \( \Cat{C} \) be any category. A \Def{tower diagram} in \( \Bold{C} \) is an injective on objects (as a function) diagram \( D: N \to \Bold{C} \) over the poset category\Tinyref{def:poset_category}, i.e.
  \begin{equation}\label{def:tower_diagram/diagram}
    \cdots \longrightarrow \bullet \longrightarrow \bullet \longrightarrow \bullet \longrightarrow \cdots
  \end{equation}
\end{definition}

\begin{definition}\label{def:commutative_diagram}
  A diagram \( D \) is said to be \Def{commutative} if, whenever we have two chains of morphisms
  \begin{align*}
    X \overset {f_1} \longrightarrow A_1 \overset {f_2} \longrightarrow \ldots \overset {f_{n-1}} \longrightarrow A_{n-1} \overset {f_n} \longrightarrow Y
  \end{align*}
  and
  \begin{align*}
    X \overset {g_1} \longrightarrow B_1 \overset {g_2} \longrightarrow \ldots \overset {g_{m-1}} \longrightarrow B_{m-1} \overset {f_m} \longrightarrow Y
  \end{align*}
  in the diagram, where \( n > 0 \) and \( m > 0 \), then necessarily
  \begin{equation*}
    f_n \circ \ldots \circ f_1 = g_m \circ \ldots \circ g_1.
  \end{equation*}

  We also say that the diagram \( D \) \Def{commutes}.
\end{definition}

\begin{example}\label{ex:commutative_diagrams}
  Consider the diagram
  \begin{equation*}
    \begin{mplibcode}
      beginfig(1);
        input metapost/graphs;

        v1 := thelabel("$A$", origin);
        v2 := thelabel("$B$", (-1, -1) scaled u);
        v3 := thelabel("$C$", (1, -1) scaled u);

        a1 := straight_arc(v1, v2);
        a2 := straight_arc(v1, v3);
        a3 := straight_arc(v2, v3);

        draw_vertices(v);
        draw_arcs(a);

        label.ulft("$f$", straight_arc_midpoint of a1);
        label.urt("$g$", straight_arc_midpoint of a2);
        label.bot("$h$", straight_arc_midpoint of a3);
      endfig;
    \end{mplibcode}
  \end{equation*}

  It is commutative if and only if \( h \circ f = g \).

  For a more convoluted example, see \cref{def:categorical_pullback}.
\end{example}

\begin{definition}\label{def:opposite_functor}\cite[definition 5.2.1]{Leinster2014}
  Given a functor \( F: \Bold A \to \Bold B \), we define \Def{opposite or dual functor} \( F^{-1}: \Cat{A}^{-1} \to \Bold{B}^{-1} \) as
  \begin{itemize}
    \item \( F^{-1}(A) = F(A) \)
    \item \( F^{-1}(f^{-1}: A' \to A) = F(f: A \to A') \)
  \end{itemize}
\end{definition}

\begin{proposition}\label{thm:functors_preserve_isomorphisms}\cite[exercise 1.2.21]{Leinster2014}
  Functors preserve isomorphisms, i.e. if \( F: \Bold A \to \Bold B \) is a (covariant) functor and \( A \cong A' \), then \( F(A) \cong F(A') \).
\end{proposition}
\begin{proof}
  Let \( f: A \to A' \) be an isomorphism with inverse \( f^{-1} \). From~\cref{def:functor}, we have
  \begin{align*}
    F(f^{-1}) \circ F(f)
    \overset{\ref{def:functor/composition_axiom}} =
    F(f^{-1} \circ f)
    =
    F(\Id_A)
    \overset{\ref{def:functor/identity_axiom}} =
    \Id_{F(A)}.
  \end{align*}

  Analogously, \( F(f) \circ F(f^{-1}) = \Id_{F(A')} \). Thus \( F(f): F(A) \to F(A') \) is an isomorphism with inverse \( F(f^{-1}) \).
\end{proof}

\begin{definition}\label{def:presheaf}\cite[definition 1.2.15]{Leinster2014}
  A \Def{presheaf} on the category \( \Bold A \) is a contravariant functor
  \begin{equation*}
    F: \Bold A \to \Cat{Set}.
  \end{equation*}
\end{definition}

\begin{example}\label{ex:topological_space_presheaf}\cite[24]{Leinster2014}
  Let \( (X, \tau) \) be a topological space. Form the category \( \Bold C \) from the poset \( (\tau, \subseteq) \) as in \cref{thm:poset_iff_poset_category}. Presheaves on \( \Bold C \) are also called presheaves on the topological space \( (X, \tau) \).

  Let \( (Y, \rho) \) be another topological space. Then the map
  \begin{align*}
    &F: \tau \MultTo C(\tau, Y) \\
    &F(U) = C(U, Y) = \{ f: U \mapsto Y, f \text{ is continuous} \}
  \end{align*}
  is a presheaf.
\end{example}

\begin{definition}\label{def:faithful_full_functor}\cite[definition 1.2.16]{Leinster2014}
  A functor \( F: \Bold A \to \Bold B \) between locally small categories is called \Def{faithful} (resp. \Def{full}) if the map
  \begin{align*}
    \Cat{A}(A, A) &\to \Bold{B}(F(A), F(A')) \\
    f &\mapsto F(f)
  \end{align*}
  is injective (resp. surjective)\Tinyref{def:function_invertibility}.
\end{definition}

\begin{example}\label{def:subcategory_functors}\cite[25]{Leinster2014}
  Let \( \Bold B \) be a subcategory of \( \Bold A \). We define the inclusion functor \( I: \Bold B \to \Bold A \) by sending each object and each morphism of \( \Bold B \) to itself within \( \Bold A \).

  Then \( I \) is faithful and, if the subcategory \( \Bold B \) is full\Tinyref{def:subcategory}, then \( I \) is also full.
\end{example}

\begin{definition}\label{def:natural_transformation}\cite[definition 1.3.1]{Leinster2014}
  Let \( \Bold A \) and \( \Bold B \) be categories and let \( F \) and \( G \) be functors from \( \Bold A \) to \( \Bold B \).

  A \Def{natural transformation} \( \alpha: F \to G \) is a family \( \{ \alpha_A: F(A) \to G(A) \}_{A \in \Bold A} \) of morphisms in \( \Bold B \) such that for every morphism \( f: A \to A' \) in \( \Bold A \), the diagram
  \begin{equation*}
    \begin{mplibcode}
      beginfig(1);
        input metapost/graphs;

        v1 := thelabel("$F(A)$", origin);
        v2 := thelabel("$G(A)$", (0, -1) scaled u);
        v3 := thelabel("$F(A')$", (2, 0) scaled u);
        v4 := thelabel("$G(A')$", (2, -1) scaled u);

        a1 := straight_arc(v1, v2);
        a2 := straight_arc(v1, v3);
        a3 := straight_arc(v2, v4);
        a4 := straight_arc(v3, v4);

        draw_vertices(v);
        draw_arcs(a);

        label.lft("$\alpha_A$", straight_arc_midpoint of a1);
        label.top("$F(f)$", straight_arc_midpoint of a2);
        label.bot("$G(f)$", straight_arc_midpoint of a3);
        label.rt("$\alpha_{A'}$", straight_arc_midpoint of a4);
      endfig;
    \end{mplibcode}
  \end{equation*}
  commutes.

  The morphisms \( \alpha_A \) are called the components of \( \alpha \). We denote natural transformations using
  \begin{equation*}
    \begin{mplibcode}
      u := 1cm;

      beginfig(1);
        input metapost/graphs;

        v1 := thelabel("$\mathbf{A}$", origin);
        v2 := thelabel("$\mathbf{B}$", (2, 0) scaled u);

        a1 := curved_arc(v1, v2, (0, safe_arc_curvature));
        a2 := curved_arc(v1, v2, (0, -safe_arc_curvature));

        draw_vertices(v);
        draw_arcs(a);

        label.top("$F$", curved_arc_midpoint of a1);
        label.bot("$G$", curved_arc_midpoint of a2);

        draw_vertical_double_arc((1, 0) scaled u);
        label.rt("$\alpha$", (1, 0) scaled u);
      endfig;
    \end{mplibcode}
  \end{equation*}

  The natural transformation from \( F \) to \( F \) composed of identity morphisms is called the \Def{identity natural transformation}.
\end{definition}

\begin{definition}\label{def:natural_transformation_composition}
  Let \( F: \Bold A \to \Bold B \), \( G: \Bold A \to \Bold B \) and \( H: \Bold A \to \Bold B \) be functors and let \( \alpha: F \to G \) and \( \beta: G \to H \) be natural transformations.

  We define the \Def{composition} (sometimes called \Def{vertical composition}) of the natural transformations \( \beta \) and \( \alpha \) component-wise for \( A \in \Bold A \) as
  \begin{equation*}
    (\beta \circ \alpha)_A \coloneqq \beta_{A} \circ \alpha_A.
  \end{equation*}
\end{definition}

\begin{definition}\label{def:functor_category}
  Given categories \( \Bold A \) and \( \Bold B \), we define their \Def{functor category} \( [\Bold A, \Bold B] \) by
  \begin{itemize}
    \item the objects in \( [\Bold A, \Bold B] \) are functors \( F: \Bold A \to \Bold B \).
    \item the morphisms in \( [\Bold A, \Bold B](F, G) \) are the natural transformations from \( F \) to \( G \).
  \end{itemize}

  The functor category \( [\Bold A, \Bold B] \) is often denoted by \( {\Bold B}^{\Bold A} \) since, if \( \Bold A \) is a finite discrete category of cardinality \( n \), it is equivalent\Tinyref{def:category_equivalence}) to the product category\Tinyref{def:product_category} \( \Bold B \times \Bold B \)
  \begin{equation*}
    {\Bold B}^{\Bold A} = {\Bold B}^n = \Bold B \times \ldots \times \Bold B.
  \end{equation*}

  If the natural transformation \( \alpha \) is an isomorphism in \( [\Bold A, \Bold B] \), we say that the categories \( \Bold A \) and \( \Bold B \) are \Def{naturally isomorphic} and write \( \Bold A \cong \Bold B \).
\end{definition}

\begin{definition}\label{def:category_equivalence}\cite[definition 1.3.15]{Leinster2014}
  An \Def{equivalence} between the categories \( \Bold A \) and \( \Bold B \) consists of a pair of functors \( F, G: \Bold A \to \Bold B \) and a pair of natural isomorphisms
  \begin{align*}
    \xi: \Id_{\Bold A} \to G \circ F,
    &&
    \eta: F \circ G \to \Id_{\Bold B}.
  \end{align*}

  If an equivalence between \( \Bold A \) and \( \Bold B \) exists, we say that \Def{the categories \( \Bold A \) and \( \Bold B \) are equivalent} and write \( \Bold A \simeq \Bold B \).

  An equivalence of the form \( \Cat{A}^{-1} \simeq \Bold{B} \) is called a \Def{duality} between \( \Bold A \) and \( \Bold B \) and we say that \Def{\( \Bold A \) is dual to \( \Bold B \)} \cite[example 1.3.22]{Leinster2014}.
\end{definition}

\begin{proposition}\label{thm:skeletal_subcategory_equivalence}\cite[91]{MacLane1994}
  Every category \( \Bold A \) is equivalent to a skeletal subcategory (if one exists; see~\cref{remark:skeletal_subcategory_exists}).
\end{proposition}

\begin{definition}\label{def:natural_transformation_horizontal_composition}\cite[remarks 1.3.24]{Leinster2014}
  Let \( \Bold A \), \( \Bold B \) and \( \Bold C \) be categories, \( F, G: \Bold A \to \Bold B \) and \( F', G': \Bold B \to \Bold C \) be functors and \( \alpha: F \to G \) and \( \alpha': F' \to G' \) be natural transformations.
  \begin{equation*}
    \begin{mplibcode}
      u := 1cm;

      beginfig(1);
        input metapost/graphs;

        v1 := thelabel("$\mathbf{A}$", origin);
        v2 := thelabel("$\mathbf{B}$", (2, 0) scaled u);
        v3 := thelabel("$\mathbf{C}$", (4, 0) scaled u);

        a1 := curved_arc(v1, v2, (0, safe_arc_curvature));
        a2 := curved_arc(v1, v2, (0, -safe_arc_curvature));
        a3 := curved_arc(v2, v3, (0, safe_arc_curvature));
        a4 := curved_arc(v2, v3, (0, -safe_arc_curvature));

        draw_vertices(v);
        draw_arcs(a);

        label.top("$F$", curved_arc_midpoint of a1);
        label.bot("$G$", curved_arc_midpoint of a2);
        label.top("$F'$", curved_arc_midpoint of a3);
        label.bot("$G'$", curved_arc_midpoint of a4);

        draw_vertical_double_arc((1, 0) scaled u);
        label.rt("$\alpha$", (1, 0) scaled u);

        draw_vertical_double_arc((3, 0) scaled u);
        label.rt("$\alpha'$", (3, 0) scaled u);
      endfig;
    \end{mplibcode}
  \end{equation*}

  We define the natural transformation
  \begin{equation*}
    \alpha' * \alpha: F' \circ F \to G' \circ G,
  \end{equation*}
  called \Def{horizontal composition of \( \alpha \) and \( \alpha' \)}, defined by
  \begin{equation*}
    (\alpha' * \alpha)_A \coloneqq \alpha'_{G(A)} \circ F'(\alpha_A) = G'(\alpha_A) \circ \alpha'_{F(A)}.
  \end{equation*}
\end{definition}

\begin{definition}\label{def:comma_category}\cite[definition 2.3.1]{Leinster2014}
  Let \( \Bold A \), \( \Bold B \) and \( \Bold C \) be categories and \( \Bold A \overset F \to \Bold C \overset G \leftarrow \Bold B \). We define the \Def{comma category} \( (F \downarrow G) \) by
  \begin{itemize}
    \item The objects in \( (F \downarrow G) \) are triples \( (A, h, B) \) where \( A \in \Bold A \), \( B \in \Bold B \) and \( F(A) \overset h \to G(B) \).
    \item The morphisms from \( (A, h, B) \) to \( (A', h', B') \) are pairs \( (f, g) \in \Cat{A}(A, A') \times \Bold{B}(B, B') \) such that the following diagram commutes:
    \begin{equation}\label{def:comma_category/universal_property}
      \begin{mplibcode}
        beginfig(1);
          input metapost/graphs;

          v1 := thelabel("$F(A)$", origin);
          v2 := thelabel("$G(B)$", (0, -1) scaled u);
          v3 := thelabel("$F(A')$", (2, 0) scaled u);
          v4 := thelabel("$G(B')$", (2, -1) scaled u);

          a1 := straight_arc(v1, v2);
          a2 := straight_arc(v1, v3);
          a3 := straight_arc(v2, v4);
          a4 := straight_arc(v3, v4);

          draw_vertices(v);
          draw_arcs(a);

          label.lft("$h$", straight_arc_midpoint of a1);
          label.top("$F(f)$", straight_arc_midpoint of a2);
          label.bot("$G(g)$", straight_arc_midpoint of a3);
          label.rt("$h'$", straight_arc_midpoint of a4);
        endfig;
      \end{mplibcode}
    \end{equation}
  \end{itemize}

  As a special case, if \( \Bold A \) is the one-object category, then \( F \) necessarily \enquote{selects} an object \( C \in \Bold C \). Thus, we can define the comma category \( (C \downarrow G) \), in which objects may be regarded as pairs \( (h, B) \) rather than triples and the diagram for morphisms looks like
  \begin{equation*}
    \begin{mplibcode}
      beginfig(1);
        input metapost/graphs;

        v1 := thelabel("$C$", origin);
        v2 := thelabel("$G(B)$", (-1, -1) scaled u);
        v3 := thelabel("$G(B')$", (1, -1) scaled u);

        a1 := straight_arc(v1, v2);
        a2 := straight_arc(v1, v3);
        a3 := straight_arc(v2, v3);

        draw_vertices(v);
        draw_arcs(a);

        label.ulft("$h$", straight_arc_midpoint of a1);
        label.urt("$h'$", straight_arc_midpoint of a2);
        label.bot("$G(g)$", straight_arc_midpoint of a3);
      endfig;
    \end{mplibcode}
  \end{equation*}

  Analogously, we can also define the category \( (F \downarrow C) \) by regarding \( G \) and not \( F \) as a functor from the one-object category.
\end{definition}
