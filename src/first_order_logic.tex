\subsection{First order logic}\label{sec:first_order_logic}

The idea of first-order logic (FOL) is to create a formal language whose semantics (given by structures) support boolean operations and can quantify over all elements of an ambient universe. Unlike in propositional logic\Tinyref{sec:propositional_logic}, there are many FOL languages.

\begin{definition}\label{def:first_order_language}\cite[definition 2.1]{Nerode2012}
  The alphabet for a \textbf{first-order predicate language}\Tinyref{def:language} \( \Cal{L} \) consists of:
  \begin{description}
    \item[Logical symbols]
    \mbox{}
    \begin{enumerate}
      \item A countable alphabet of variables \( \Bold{Var}_{\Cal{L}} \), usually denoted by \( x_0, x_1, \ldots \) or \( x, y, z \).

      \item Certain propositional operations:
      \begin{description}
        \RItem{def:propositional_logic_language/constants} \( \top \) and \( \bot \) - zero-arity operations
        \RItem{def:propositional_logic_language/negation} \( \neg \) - unary operation
        \RItem{def:propositional_logic_language/connectives} \( \Sigma = \{ \land, \lor, \implies, \iff, \downarrow, \uparrow \} \) - binary operations
      \end{description}

      \item Quantifiers
      \begin{itemize}
        \item \( \forall \) (universal quantifier)
        \item \( \exists \) (existential quantifier)
      \end{itemize}

      \item Parentheses \( ( \) and \( ) \) for defining the order of operations unambiguously (see \cref{note:propositional_formula_parentheses}).

      \item Optionally, an equality symbol \( \doteq \).
    \end{enumerate}

    \item[Non-logical symbols]
    \mbox{}
    \begin{enumerate}
      \item A set of functional symbols, \( \Bold{Func}_{\Cal{L}} \), whose elements are usually denoted by \( f_0, f_1, \ldots \) or \( f, g, h \). Each functional symbol has an associated natural number called its \textbf{arity}, denoted by \( \#_{\Cal{L}} f \). Functional symbols with a zero arity are called \textbf{constants}.

      \item A set of predicate symbols, \( \Bold{Pred}_{\Cal{L}} \), whose elements are usually denoted by \( p_0, p_1, \ldots \) or by symbols like \( \oplus \) or \( \circ \). Predicate symbols also have an associated arity. Predicate symbols with zero arity are called \textbf{propositional variables}.
    \end{enumerate}
  \end{description}
\end{definition}

\begin{example}\label{ex:algebraic_theory_language}\cite[remark 2.1.4]{Leinster2014}
  Most algebraic structures (with the notable exception of fields) can be defined as first-order languages with equality, no predicates and a set of functional symbols called \textbf{algebraic operations}.
  \begin{itemize}
    \item Group theory\Tinyref{sec:groups} has
    \begin{itemize}
      \item one zero-arity operation called its identity element \( e \)
      \item one unitary operation \( (\cdot)^{-1} \) called the inverse element
      \item one binary operation \( \oplus \) called the group operation
    \end{itemize}

    \item Linear algebra\Tinyref{sec:vector_spaces} has
    \begin{itemize}
      \item one zero-arity operation called its zero element \( 0 \)
      \item one binary operation \( + \) called vector sum
      \item for every scalar \( \lambda \) in the underlying field, a unitary operation \( \lambda \cdot \) called scalar multiplication by \( \lambda \)
    \end{itemize}
  \end{itemize}
\end{example}

\begin{definition}\label{def:first_order_term}\cite[definition 2.2]{Nerode2012}
  Given a FOL language \( \Cal{L} \), the set \( \Cal{T}_{\Cal{L}} \) of terms is defined by structural induction as
  \begin{itemize}
    \item Each variable is a term
    \item If \( \tau_1, \ldots, \tau_n \) are terms and \( f \) is a functional symbol with arity \( n \), then the following word is also a term:
    \begin{align*}
      f(\tau_1, \ldots, \tau_n)
    \end{align*}
  \end{itemize}

  In particular, constants are also terms.

  Furthermore, the grammar of first-order terms is unambiguous (see \cref{thm:first_order_formulas_are_unambiguous}).

  For each term \( \tau \), we define its variables as
  \begin{align*}
    \Bold{Free}(\tau) \coloneqq \begin{cases}
      x,                                                        &\tau = x \in \Bold{Var}_{\Cal{L}}, \\
      \Bold{Free}(\tau_1) \cup \ldots \cup \Bold{Free}(\tau_n), &\tau = f(\tau_1, \ldots, \tau_n).
    \end{cases}
  \end{align*}
\end{definition}

\begin{definition}\label{def:first_order_formula}\cite[definition 2.5]{Nerode2012}
  Given a FOL language \( \Cal{L} \), we define the set of atomic formulas inductively as
  \begin{itemize}
    \item Both \( \top \) and \( \bot \) are atomic formulas.
    \item If \( p \) is an n-ary predicate symbol and if \( \tau_1, \ldots, \tau_n \) are terms, then \( p(\tau_1, \ldots, \tau_n) \) is an atomic formula.
    \item If \( \Cal{L} \) has an equality symbol and if \( \tau_1, \tau_2 \) are terms, then \( (\tau_1 \doteq \tau_2) \) is an atomic formula.
  \end{itemize}

  The set \( \Cal{F}_{\Cal{L}} \) of predicate formulas is then defined as
  \begin{itemize}
    \item All atomic formulas are formulas
    \item If \( \varphi \) is a formula, its negation \( \neg \varphi \) is also a formula
    \item If \( \varphi \) and \( \psi \) are formulas, then \( (\varphi \circ \psi), \circ \in \Sigma \)\Tinyref{def:propositional_logic_language}, are also formulas
    \item If \( \varphi \) is a formula and \( x \) is a variable, then the following are also formulas:
    \begin{itemize}
      \item \( \forall x \varphi \)
      \item \( \exists x \varphi \)
    \end{itemize}
  \end{itemize}

  Furthermore, the grammar of first-order formulas is unambiguous (see \cref{thm:first_order_formulas_are_unambiguous}).

  For each formula \( \varphi \), we define its free and bound variables as
  \begin{align*}
    \Bold{Free}(\varphi) \coloneqq \begin{cases}
      \varnothing,                                              &\varphi \in \{ \top, \bot \} \\
      \Bold{Free}(\tau_1) \cup \ldots \cup \Bold{Free}(\tau_n), &\varphi = p(\tau_1, \ldots, \tau_n) \\
      \Bold{Free}(\tau_1) \cup \Bold{Free}(\tau_2),             &\varphi = (\tau_1 \doteq \tau_2), \\
      \Bold{Free}(\psi),                                        &\varphi = \neg \psi, \\
      \Bold{Free}(\psi_1) \cup \Bold{Free}(\psi_2),             &\varphi = \psi_1 \circ \psi_2, \circ \in \Sigma, \\
      \Bold{Free}(\psi) \setminus \{ x \},                      &\varphi = Q x \psi, Q \in \{ \forall, \exists \}
    \end{cases}
  \end{align*}
  and
  \begin{align*}
    \Bold{Bound}(\varphi) \coloneqq \begin{cases}
      \varnothing,                                              &\varphi \in \{ \top, \bot \} \\
      \varnothing,                                              &\varphi = p(\tau_1, \ldots, \tau_n) \\
      \varnothing,                                              &\varphi = (\tau_1 \doteq \tau_2), \\
      \Bold{Bound}(\psi),                                       &\varphi = \neg \psi, \\
      \Bold{Bound}(\psi_1) \cup \Bold{Bound}(\psi_2),           &\varphi = \psi_1 \circ \psi_2, \circ \in \Sigma, \\
      \Bold{Bound}(\psi) \cup \{ x \},                          &\varphi = Q x \psi, Q \in \{ \forall, \exists \}.
    \end{cases}
  \end{align*}

  A formula is called \textbf{closed} if it has no bound variables.

  If a formula \( \varphi \) has free variables \( \Bold{Free} = \{ x_1, \ldots, x_n \} \), a common convention is to write it as
  \begin{align*}
    \varphi(x_1, \ldots, x_n).
  \end{align*}

  This highlights that formulas with free variables can act as predicates, however their semantics are completely determined, unlike the semantics of predicates.

  Analogously to \cref{def:propositional_theory}, we define a \textbf{first-order theory} to be a set of formulas along with any additional axioms, like the ones from \cref{note:minimal_first_order_language} and \cref{note:first_order_equality}.
\end{definition}

\begin{proposition}\label{thm:first_order_formulas_are_unambiguous}
  The grammar\Tinyref{def:grammar}
  \begin{displaymath}
    \begin{aligned}
      &\Theta \to v,                                          && v \in \Bold{Var} \\
      &\tau \to \Theta,                                       && \\
      &\tau \to f(\tau, \ldots, \tau),                        && f \in \Bold{Func} \text{ is an } n-\text{ary functional symbol} \\
      &\Phi \to \top \;|\; \bot                               && \\
      &\Phi \to p(\tau, \ldots, \tau),                        && p \in \Bold{Pred} \text{ is an } n-\text{ary predicate symbol} \\
      &\Phi \to (\tau \doteq \tau)                            && \\
      &\Phi \to \neg \Phi                                     && \\
      &\Phi \to (\Phi \circ \Phi),                            && \circ \in \Sigma \\
      &\Phi \to \forall \Theta \Phi \;|\; \exists \Theta \Phi && \\
    \end{aligned}
  \end{displaymath}
  of first order formulas\Tinyref{def:first_order_formula} is unambiguous\Tinyref{def:ambiguous_grammar}.
\end{proposition}
\begin{proof}
  The proof is more complicated but similar to \cref{thm:propositional_formulas_are_unambiguous}.
\end{proof}

\begin{note}\label{note:minimal_first_order_language}
  As in \cref{note:minimal_propositional_language}, to avoid redundancy in definitions and proofs, we can use the Pierce arrow \( \downarrow \) to define the constants, negation and all other connectives by adding additional axioms to every theory.
\end{note}

\begin{note}\label{note:first_order_equality}\cite[definition 5.1]{Nerode2012}
  Equality is a concept that implies that two objects are completely indistinguishable. Let \( \Cal{L} \) be a first-order language with an equality symbol. In order to make equality behave as expected, we want the following formulas to be added implicitly to any theory:

  \begin{defenum}
    \item\label{note:first_order_equality/reflexivity} for any \( x \in \Bold{Var}_{\Cal{L}} \), add the formula \( (x \doteq x) \).
    \item\label{note:first_order_equality/equality} for any four variables \( x_1, x_2, y_1, y_2 \), add
    \begin{align*}
      ((x_1 \doteq y_1) \land (x_2 \doteq y_2)) \implies ((x_1 \doteq x_2) \iff (y_1 \doteq y_2)).
    \end{align*}

    \item\label{note:first_order_equality/functions} for any \( n \)-ary function \( f \) and any set \( \{ x_1, \ldots, x_n, y_1, \ldots, y_n \} \subseteq \Bold{Var} \), add
    \begin{align*}
      ((x_1 \doteq y_1) \land \ldots \land (x_n \doteq y_n)) \implies (f(x_1, \ldots, x_n) \doteq f(y_1, \ldots, y_n)).
    \end{align*}

    \item\label{note:first_order_equality/predicates} analogously, for any \( n \)-ary predicate \( p \), add
    \begin{align*}
      ((x_1 \doteq y_1) \land \ldots \land (x_n \doteq y_n)) \implies (p(x_1, \ldots, x_n) \iff p(y_1, \ldots, y_n)).
    \end{align*}
  \end{defenum}

  In particular, this ensures that equality is an equivalence relation (see \cref{thm:first_order_equality_equivalence_relation}).
\end{note}

\begin{definition}\label{def:first_order_substition}
  Let \( \varphi \) be a first-order formula with a free variable \( y \) and \( \rho \) be a term. We define the \textbf{substitions}
  \begin{align*}
    \tau[y \to \rho] &\coloneqq \begin{cases}
      \rho,                                              &\tau = y, \\
      x,                                                 &\tau = x \in \Bold{Var}_{\Cal{L}} \setminus \{ y \}, \\
      f(\tau_1[y \to \rho], \ldots, \tau_n[y \to \rho]), &\tau = f(\tau_1, \ldots, \tau_n).
    \end{cases}
    \\
    \varphi[y \to \rho] &\coloneqq \begin{cases}
      \varphi,                                           &\varphi \in \{ \top, \bot \} \\
      p(\tau_1[y \to \rho], \ldots, \tau_n[y \to \rho]), &\varphi = p(\tau_1, \ldots, \tau_n) \\
      (\tau_1[y \to \rho] \doteq \tau_2[y \to \rho]),    &\varphi = (\tau_1 \doteq \tau_2), \\
      \neg \psi[y \to \rho],                             &\varphi = \neg \psi, \\
      \psi_1[y \to \rho] \circ \psi_2[x \to \rho],       &\varphi = \psi_1 \circ \psi_2, \circ \in \Sigma, \\
      Q x \psi[y \to \rho],                              &\varphi = Q x \psi, Q \in \{ \forall, \exists \}, x \not\in \Bold{Free}(\rho), \\
      Q x \psi[y \to \rho[x \to z]],                     &\varphi = Q x \psi, Q \in \{ \forall, \exists \}, x \in \Bold{Free}(\rho)
    \end{cases}
  \end{align*}
  where in the last step \( z \in \Bold{Var} \setminus \Bold{Free}(\rho) \).

  We define \textbf{simultaneous substition of \( y_1, \ldots, y_n \) with \( \rho_1, \ldots, \rho_n \)} analogously to \cref{def:propositional_substition}.
\end{definition}

\begin{definition}\label{def:first_order_structure}\cite[definition 4.1]{Nerode2012}
  Fix a FOL language \( \Cal{L} \). A \textbf{structure} for \( \Cal{L} \) consists of:
  \begin{enumerate}
    \item A nonempty set \( A \).
    \item A binary relation\Tinyref{def:relation} \( I(\doteq) subseteq A^2 \) called the \textbf{interpretation of the equality}.
    \item For every \( n \)-ary function symbol \( f \), a function\Tinyref{def:function} \( I(f): A^n \to A \) called the \textbf{interpretation of \( f \)}.
    \item For every \( n \)-ary predicate \( p \), an n-ary relation\Tinyref{def:relation} \( I(p) \subseteq A^n \) called the \textbf{interpretation of \( p \)}, i.e. all tuples of values that satisfy the predicate within the structure.
  \end{enumerate}
\end{definition}

\begin{definition}\label{def:first_order_evaluation}
  Fix a structure \( \Cal{A} = (A, I) \) for a FOL language \( \Cal{L} \). An \textbf{evaluation for the variables of \( \Cal{L} \)} is any function \( v: \Bold{Var}_{\Cal{L}} \to A \).

  For every variable \( x \) and every universe element \( a \in A \) we also define the \textbf{modified at \( x \) with \( a \) evaluation}
  \begin{align*}
    v_a^x(y) \coloneqq \begin{cases}
      a,    &y = x, \\
      v(y), &y \neq x.
    \end{cases}
  \end{align*}

  Inductively,
  \begin{align*}
    v_{a_1, \ldots, a_n}^{x_1, \ldots, x_n}(y) \coloneqq ((v_{a_1}^{x_1})_{a_2}^{x_2})\cdots_{a_n}^{x_n}.
  \end{align*}

  This allows us to define semantics for all terms:
  \begin{align*}
    \tau[v] \coloneqq \begin{cases}
      v(x),                               &\tau = x \in \Bold{Var}_{\Cal{L}}, \\
      I(f)(\tau_1[v], \ldots, \tau_n[v]), &\tau = f(\tau_1, \ldots, \tau_n).
    \end{cases}
  \end{align*}
  and all formulas:
  \begin{align*}
    \varphi[v] \coloneqq \begin{cases}
      T,                                                &\varphi = \top, \\
      F,                                                &\varphi = \bot, \\
      (\tau_1[v], \tau_2[v]) \in I(\doteq),             &\varphi = (\tau_1 \doteq \tau_2), \\
      (\tau_1[v], \ldots, \tau_n[v]) \in I(p),          &\varphi = p(\tau_1, \ldots, \tau_n), \\
      H_\neg(\psi[v]),                                  &\varphi = \neg \psi, \\
      H_\circ(\psi_1[v], \psi_2[v]),                    &\varphi = \psi_1 \circ \psi_2, \circ \in \Sigma, \\
      \text{for all } a \in A, \psi[v_a^x] = T,         &\varphi = \forall x \psi, \\
      \text{there exists } a \in A: \psi[v_a^x] = T,    &\varphi = \exists x \psi.
    \end{cases}
  \end{align*}

  If \( \varphi[v] = T \), we say that \textbf{\( \varphi \) is true in \( \Cal{A} \) under the evaluation \( v \)} and we write \( \Cal{A} \models_v \varphi \). If \( \varphi \) is true in \( \Cal{A} \) under every evaluation, we say that \textbf{\( \varphi \) is true or valid in \( \Cal{A} \)} and we write \( \Cal{A} \models \varphi \).

  Given a formula \( \varphi(x_1, \ldots, x_n) \), we write
  \begin{align*}
    \varphi(a_1, \ldots, a_n) \coloneqq \varphi(x_1, \ldots, x_n)[v_{a_1, \ldots, a_n}^{x_1, \ldots, x_n}].
  \end{align*}
\end{definition}

\begin{definition}\label{def:first_order_model}\cite[definition 4.4]{Nerode2012}
  A \textbf{model} for a first-order theory \( \Gamma \) in the FOL language \( \Cal{L} \) is a structure \( \Cal{A} \) such that there exists a single evaluation \( v \) so that for every formula \( \gamma \in \Gamma \), we have \( \Cal{A} \models_v \gamma \). We write \( \Cal{A} \models_v \Gamma \) or simply \( \Cal{A} \models \Gamma \).
\end{definition}

\begin{definition}\label{def:first_order_consistent}
  A first-order theory is \textbf{consistent} if, under any evaluation in any structure, every formula is either true or false.
\end{definition}

\begin{proposition}\label{thm:first_order_equality_equivalence_relation}
  In a FOL language with equality, the equality is an equivalence relation\Tinyref{def:order/equivalence}, that is, for any structure\Tinyref{def:first_order_structure} \( \Cal{A} \), we have
  \begin{description}
    \DItem{reflexivity}{thm:first_order_equality_equivalence_relation/reflexivity} \( \Cal{A} \models \forall x (x \doteq x) \)
    \DItem{symmetry}{thm:first_order_equality_equivalence_relation/symmetry} \( \Cal{A} \models \forall x \forall y ((x \doteq y) \iff (y \doteq x)) \)
    \DItem{transitivity}{thm:first_order_equality_equivalence_relation/transitivity} \( \Cal{A} \models \forall x \forall y \forall z (((x \doteq y) \land (y \doteq x)) \implies (x \doteq z)) \)
  \end{description}
\end{proposition}
\begin{proof}
  Let \( \Cal{A} = (A, I) \) be a structure and let \( v: A \to \{ T, F \} \) be an evaluation function\Tinyref{def:first_order_evaluation}. Then

  \begin{description}
    \RItem{thm:first_order_equality_equivalence_relation/reflexivity} The evaluation \( (\forall x (x \doteq x))[v] \) is true if and only if for every \( a \in A \), we have
    \begin{align*}
      (x \doteq x)[v_x^a] = T.
    \end{align*}

    By \cref{note:first_order_equality/reflexivity}, \( (y \doteq y) \) is an axiom for every \( y \in \Bold{Var}_{\Cal{L}} \), hence \mbox{\( (x \doteq x)[v_x^a] = T \)} for all \( a \in A \).We conclude that
    \begin{align*}
      \Cal{A} \models_v \forall x (x \doteq x).
    \end{align*}

    \RItem{def:order/equivalence/symmetry} Let \( a, b \in A \) be arbitrary. Since \( (x \doteq x) \) is an axiom for every \( x \in \Bold{Var} \), from \cref{note:first_order_equality/equality} we obtain
    \begin{align*}
      T &=
      (((x \doteq x) \land (x \doteq y)) \implies ((x \doteq x) \iff (y \doteq x)))[v_{x,y}^{a,b}]
      = \\ &=
      H_\Rightarrow(H_\land((x \doteq x)[v_{x,y}^{a,b}], (x \doteq y)[v_{x,y}^{a,b}]), H_\Leftrightarrow((x \doteq x)[v_{x,y}^{a,b}], (y \doteq x)[v_{x,y}^{a,b}]))
      = \\ &=
      H_\Rightarrow(H_\land(T, (x \doteq y)[v_{x,y}^{a,b}]), H_\Leftrightarrow(T, (y \doteq x)[v_{x,y}^{a,b}]))
      = \\ &=
      H_\Leftrightarrow((x \doteq y)[v_{x,y}^{a,b}], (y \doteq x)[v_{x,y}^{a,b}])
      = \\ &=
      ((x \doteq y) \iff (y \doteq x))[v_{x,y}^{a,b}].
    \end{align*}

    Both \( a \) and \( b \) were arbitrary, hence
    \begin{align*}
      \Cal{A} \models_v \forall x \forall y ((x \doteq y) \iff (y \doteq x)).
    \end{align*}

    \RItem{def:order/equivalence/transitivity} Analogously to \ref{def:order/equivalence/symmetry}, let \( a, b, c \in A \). From \cref{note:first_order_equality/equality} we obtain
    \begin{align*}
      T &=
      (((x \doteq y) \land (z \doteq y)) \implies ((x \doteq z) \iff (y \doteq y)))[v_{x,y,z}^{a,b,c}]
      = \\ &=
      H_\Rightarrow(H_\land((x \doteq y)[v_{x,y,z}^{a,b,c}], (z \doteq y)[v_{x,y,z}^{a,b,c}]), H_\Leftrightarrow((x \doteq z)[v_{x,y,z}^{a,b,c}], (y \doteq y)[v_{x,y,z}^{a,b,c}]))
      = \\ &=
      H_\Rightarrow(H_\land((x \doteq y)[v_{x,y,z}^{a,b,c}], (z \doteq y)[v_{x,y,z}^{a,b,c}]), H_\Leftrightarrow((x \doteq z)[v_{x,y,z}^{a,b,c}], T))
      = \\ &=
      H_\Rightarrow(H_\land((x \doteq y)[v_{x,y,z}^{a,b,c}], (z \doteq y)[v_{x,y,z}^{a,b,c}]), (x \doteq z)[v_{x,y,z}^{a,b,c}]))
      = \\ &=
      (((x \doteq y) \land (z \doteq y)) \implies (x \doteq z))[v_{x,y,z}^{a,b,c}].
    \end{align*}

    The values \( a \), \( b \) and \( c \) were arbitrary, hence
    \begin{align*}
      \Cal{A} \models_v \forall x \forall y \forall z (((x \doteq y) \land (z \doteq y)) \implies (x \doteq z)).
    \end{align*}
  \end{description}
\end{proof}
