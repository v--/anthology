\subsection{First order logic}\label{subsec:first_order_logic}

\begin{definition}\label{def:first_order_language}\cite[19]{Lectures:logic_programming}
  The idea of first-order logic is to create a formal language whose semantics (given by structures) support boolean operations and can quantify over all elements of an ambient universum. Unlike in propositional logic\Tinyref{subsec:propositional_logic}, there are many first-order languages.

  The alphabet for a \Def{first-order predicate language}\Tinyref{def:language} \( \Cal{L} \) consists of:
  \begin{description}
    \item[Logical symbols]
    \mbox{}
    \begin{enumerate}
      \item A countable alphabet of variables \( \Cat{Var}_{\Cal{L}} \), usually denoted by \( \xi_0, \xi_1, \ldots \) or \( \xi, \eta, \zeta \).

      \item Certain propositional operations:
      \begin{description}
        \RItem{def:propositional_logic_language/constants} \( \top \) and \( \bot \) - zero-arity operations
        \RItem{def:propositional_logic_language/negation} \( \neg \) - unary operation
        \RItem{def:propositional_logic_language/connectives} \( \Sigma = \{ \land, \lor, \implies, \iff, \downarrow, \uparrow \} \) - binary operations
      \end{description}

      \item Quantifiers \( Q = ( \forall, \exists ) \)
      \begin{description}
        \DItem{def:propositional_logic_language/universal_quantifier}[universal quantifier] \( \forall \)
        \DItem{def:propositional_logic_language/existential_quantifier}[existential quantifier] \( \exists \)
      \end{description}

      \item Parentheses \( ( \) and \( ) \) for defining the order of operations unambiguously (see \cref{remark:propositional_formula_parentheses}).

      \item Optionally, an equality symbol \( \doteq \).
    \end{enumerate}

    \item[Non-logical symbols]
    \mbox{}
    \begin{enumerate}
      \item A set of functional symbols, \( \Cat{Func}_{\Cal{L}} \), whose elements are usually denoted by \( f_0, f_1, \ldots \) or \( f, g, h \). Each functional symbol has an associated natural number called its \Def{arity}, denoted by \( \#_{\Cal{L}} f \). Functional symbols with a zero arity are called \Def{constants}.

      \item A set of predicate symbols, \( \Cat{Pred}_{\Cal{L}} \), whose elements are usually denoted by \( p_0, p_1, \ldots \) or by symbols like \( \oplus \) or \( \circ \). Predicate symbols also have an associated arity. Predicate symbols with zero arity are called \Def{propositional variables}.
    \end{enumerate}
  \end{description}
\end{definition}

\begin{example}\label{ex:first_order_languages}
  Examples of first-order languages include
  \begin{itemize}
    \item \Cref{def:peano_arithmetic} defines the Peano arithmetic
    \item \Cref{def:algebraic_theory} defines different algebraic theories
  \end{itemize}
\end{example}

\begin{definition}\label{def:first_order_term}\cite[20]{Lectures:logic_programming}
  Given a first-order language \( \Cal{L} \), the set \( \Cal{T}_{\Cal{L}} \) of terms is defined by structural induction as
  \begin{itemize}
    \item Each variable is a term
    \item If \( \tau_1, \ldots, \tau_n \) are terms and \( f \) is a functional symbol with arity \( n \), then the following word is also a term:
    \begin{equation*}
      f(\tau_1, \ldots, \tau_n)
    \end{equation*}
  \end{itemize}

  In particular, constants are terms.

  Furthermore, the grammar of first-order terms is unambiguous (see \cref{thm:first_order_formulas_are_unambiguous}).

  For each term \( \tau \), we define its variables as
  \begin{align*}
    \Cat{Free}(\tau) \coloneqq \begin{cases}
      \xi,                                                      &\tau = \xi \in \Cat{Var}_{\Cal{L}}, \\
      \Cat{Free}(\tau_1) \cup \ldots \cup \Bold{Free}(\tau_n), &\tau = f(\tau_1, \ldots, \tau_n).
    \end{cases}
  \end{align*}
\end{definition}

\begin{definition}\label{def:first_order_formula}\cite[20]{Lectures:logic_programming}
  Given a first-order language \( \Cal{L} \), we define the set of atomic formulas inductively as
  \begin{itemize}
    \item Both \( \top \) and \( \bot \) are atomic formulas.
    \item If \( p \) is an n-ary predicate symbol and if \( \tau_1, \ldots, \tau_n \) are terms, then \( p(\tau_1, \ldots, \tau_n) \) is an atomic formula.
    \item If \( \Cal{L} \) has an equality symbol and if \( \tau_1, \tau_2 \) are terms, then \( (\tau_1 \doteq \tau_2) \) is an atomic formula.
  \end{itemize}

  The set \( \Cal{F}_{\Cal{L}} \) of predicate formulas is then defined as
  \begin{itemize}
    \item All atomic formulas are formulas
    \item If \( \varphi \) is a formula, its negation \( \neg \varphi \) is also a formula
    \item If \( \varphi \) and \( \psi \) are formulas, then \( (\varphi \circ \psi), \circ \in \Sigma \)\Tinyref{def:propositional_logic_language}, are also formulas
    \item If \( \varphi \) is a formula and \( \xi \) is a variable, then the following are also formulas:
    \begin{itemize}
      \item \( \forall \xi \varphi \)
      \item \( \exists \xi \varphi \)
    \end{itemize}
  \end{itemize}

  Furthermore, the grammar of first-order formulas is unambiguous (see \cref{thm:first_order_formulas_are_unambiguous}).

  For each formula \( \varphi \), we define its free and bound variables as
  \begin{align*}
    \Cat{Free}(\varphi) \coloneqq \begin{cases}
      \varnothing,                                              &\varphi \in \{ \top, \bot \} \\
      \Cat{Free}(\tau_1) \cup \ldots \cup \Bold{Free}(\tau_n), &\varphi = p(\tau_1, \ldots, \tau_n) \\
      \Cat{Free}(\tau_1) \cup \Bold{Free}(\tau_2),             &\varphi = (\tau_1 \doteq \tau_2), \\
      \Cat{Free}(\psi),                                        &\varphi = \neg \psi, \\
      \Cat{Free}(\psi_1) \cup \Bold{Free}(\psi_2),             &\varphi = \psi_1 \circ \psi_2, \circ \in \Sigma, \\
      \Cat{Free}(\psi) \setminus \{ \xi \},                      &\varphi = Q \xi \psi, Q \in \{ \forall, \exists \}
    \end{cases}
  \end{align*}
  and
  \begin{align*}
    \Cat{Bound}(\varphi) \coloneqq \begin{cases}
      \varnothing,                                              &\varphi \in \{ \top, \bot \} \\
      \varnothing,                                              &\varphi = p(\tau_1, \ldots, \tau_n) \\
      \varnothing,                                              &\varphi = (\tau_1 \doteq \tau_2), \\
      \Cat{Bound}(\psi),                                       &\varphi = \neg \psi, \\
      \Cat{Bound}(\psi_1) \cup \Bold{Bound}(\psi_2),           &\varphi = \psi_1 \circ \psi_2, \circ \in \Sigma, \\
      \Cat{Bound}(\psi) \cup \{ \xi \},                          &\varphi = Q \xi \psi, Q \in \{ \forall, \exists \}.
    \end{cases}
  \end{align*}

  A formula is called \Def{closed} if it has no bound variables.

  If a formula \( \varphi \) has free variables \( \Cat{Free}(\varphi) = \{ \xi_1, \ldots, \xi_n \} \), we write it as
  \begin{equation*}
    \varphi(\xi_1, \ldots, \xi_n).
  \end{equation*}

  This highlights that formulas with free variables can act as predicates, however their semantics\Tinyref{def:first_order_evaluation} are completely determined by the actual predicates.
\end{definition}

\begin{proposition}\label{thm:first_order_formulas_are_unambiguous}
  The grammar\Tinyref{def:grammar}
  \begin{equation*}
    \begin{aligned}
      &\Theta \to v,                                          && v \in \Cat{Var} \\
      &\tau \to \Theta,                                       && \\
      &\tau \to f(\tau, \ldots, \tau),                        && f \in \Cat{Func} \text{ is an } n-\text{ary functional symbol} \\
      &\Phi \to \top \;|\; \bot                               && \\
      &\Phi \to p(\tau, \ldots, \tau),                        && p \in \Cat{Pred} \text{ is an } n-\text{ary predicate symbol} \\
      &\Phi \to (\tau \doteq \tau)                            && \\
      &\Phi \to \neg \Phi                                     && \\
      &\Phi \to (\Phi \circ \Phi),                            && \circ \in \Sigma \\
      &\Phi \to \forall \Theta \Phi \;|\; \exists \Theta \Phi && \\
    \end{aligned}
  \end{equation*}
  of first order terms\Tinyref{def:first_order_term} and formulas\Tinyref{def:first_order_formula} is unambiguous\Tinyref{def:ambiguous_grammar}.
\end{proposition}
\begin{proof}
  The proof is more complicated but similar to \cref{thm:propositional_formulas_are_unambiguous}.
\end{proof}

\begin{remark}\label{remark:minimal_first_order_language}
  As in \cref{remark:minimal_propositional_language}, to avoid redundancy in definitions and proofs, we can use the Pierce arrow \( \downarrow \) to define the constants, negation and all other connectives by adding additional axioms to every set of formulas (see \cref{remark:propositional_axioms}).
\end{remark}

\begin{remark}\label{remark:first_order_equality}
  Equality is a concept that implies that two objects are completely indistinguishable. Let \( \Cal{L} \) be a first-order language with an equality symbol. In order to make equality behave as expected, we want the following formulas to be added implicitly to every set of formulas (see \cref{remark:propositional_axioms}):

  \begin{defenum}
    \DItem{remark:first_order_equality/reflexivity} for any \( \xi \in \Cat{Var}_{\Cal{L}} \), add the formula \( (\xi \doteq \xi) \).
    \DItem{remark:first_order_equality/equality} for any four variables \( \xi_1, \xi_2, \eta_1, \eta_2 \), add
    \begin{equation*}
      ((\xi_1 \doteq \eta_1) \land (\xi_2 \doteq \eta_2)) \implies ((\xi_1 \doteq \xi_2) \iff (\eta_1 \doteq \eta_2)).
    \end{equation*}

    \DItem{remark:first_order_equality/functions} for any \( n \)-ary function \( f \) and any set \( \{ \xi_1, \ldots, \xi_n, \eta_1, \ldots, \eta_n \} \subseteq \Cat{Var} \), add
    \begin{equation*}
      ((\xi_1 \doteq \eta_1) \land \ldots \land (\xi_n \doteq \eta_n)) \implies (f(\xi_1, \ldots, \xi_n) \doteq f(\eta_1, \ldots, \eta_n)).
    \end{equation*}

    \DItem{remark:first_order_equality/predicates} analogously, for any \( n \)-ary predicate \( p \), add
    \begin{equation*}
      ((\xi_1 \doteq \eta_1) \land \ldots \land (\xi_n \doteq \eta_n)) \implies (p(\xi_1, \ldots, \xi_n) \iff p(\eta_1, \ldots, \eta_n)).
    \end{equation*}
  \end{defenum}

  In particular, this ensures that equality is an equivalence relation (see \cref{thm:first_order_equality_is_equivalence_relation}).
\end{remark}

\begin{definition}\label{def:first_order_substition}
  Let \( \varphi \) be a first-order formula with a free variable \( \eta \) and \( \rho \) be a term. We define the \Def{substitions}
  \begin{align*}
    \tau[\eta \to \rho] &\coloneqq \begin{cases}
      \rho,                                                    &\tau = \eta, \\
      \xi,                                                     &\tau = \xi \in \Cat{Var}_{\Cal{L}} \setminus \{ \eta \}, \\
      f(\tau_1[\eta \to \rho], \ldots, \tau_n[\eta \to \rho]), &\tau = f(\tau_1, \ldots, \tau_n).
    \end{cases}
    \\
    \varphi[\eta \to \rho] &\coloneqq \begin{cases}
      \varphi,                                                 &\varphi \in \{ \top, \bot \} \\
      p(\tau_1[\eta \to \rho], \ldots, \tau_n[\eta \to \rho]), &\varphi = p(\tau_1, \ldots, \tau_n) \\
      (\tau_1[\eta \to \rho] \doteq \tau_2[\eta \to \rho]),    &\varphi = (\tau_1 \doteq \tau_2), \\
      \neg \psi[\eta \to \rho],                                &\varphi = \neg \psi, \\
      \psi_1[\eta \to \rho] \circ \psi_2[\xi \to \rho],          &\varphi = \psi_1 \circ \psi_2, \circ \in \Sigma, \\
      Q \xi \psi[\eta \to \rho],                               &\varphi = Q \xi \psi, Q \in \{ \forall, \exists \}, \xi \not\in \Cat{Free}(\rho), \\
      Q \xi \psi[\eta \to \rho[\xi \to \zeta]],                &\varphi = Q \xi \psi, Q \in \{ \forall, \exists \}, \xi \in \Cat{Free}(\rho)
    \end{cases}
  \end{align*}
  where in the last step \( \zeta \in \Cat{Var} \setminus \Bold{Free}(\rho) \).

  We define \Def{simultaneous substition of \( \eta_1, \ldots, \eta_n \) with \( \rho_1, \ldots, \rho_n \)} analogously to \cref{def:propositional_substition}.
\end{definition}

\begin{definition}\label{def:first_order_structure}\cite[25]{Lectures:logic_programming}
  Fix a first-order language \( \Cal{L} \). A \Def{structure} \( \Cal{A} = (A, I) \) for \( \Cal{L} \) consists of:
  \begin{enumerate}
    \item A nonempty set \( A \).
    \item A binary relation\Tinyref{def:relation} \( I(\doteq) \subseteq A^2 \) called the \Def{interpretation of the equality}.
    \item For every \( n \)-ary function symbol \( f \), a function\Tinyref{def:function} \( I(f): A^n \to A \) called the \Def{interpretation of \( f \)}.
    \item For every \( n \)-ary predicate \( p \), an n-ary relation\Tinyref{def:relation} \( I(p) \subseteq A^n \) called the \Def{interpretation of \( p \)}, i.e. all tuples of values that satisfy the predicate within the structure.
  \end{enumerate}

  Some additional definitions follow.

  \begin{itemize}
    \DItem{def:first_order_structure/substructure} If \( \Cal{A} = (A, I) \) is a structure and \( A' \subseteq A \), then we say that \( \Cal{A}' = (A', I) \) is a \Def{substructure} of \( \Cal{A} \) if it is closed under function application, that is, for any function symbol \( f \) with arity \( n \), we have \( I(f)(A'^n) \subseteq A' \).

    If \( A' \neq A \), we say that is is a \Def{proper substructure}.

    The family of all subalgebras of \( A \) can be ordered under set inclusion\Tinyref{def:subset}.

    \DItem{def:first_order_structure/minimal} A structure \( \Cal{O} \) is called a \Def{trivial} or \Def{zero} structure if it can be embedded homomorphically \Tinyref{def:first_order_homomorphism/embedding} into any structure for \( \Cal{L} \).
  \end{itemize}
\end{definition}

\begin{definition}\label{def:first_order_evaluation}\cite[25]{Lectures:logic_programming}
  Fix a structure \( \Cal{A} = (A, I) \) for a first-order language \( \Cal{L} \). An \Def{evaluation for the variables of \( \Cal{L} \)} is any function \( v: \Cat{Var}_{\Cal{L}} \to A \) (loosely similar to \cref{def:propositional_interpretation}).

  For every variable \( \xi \) and every universum element \( x \in A \) we also define the \Def{modified evaluation} at \( \xi \) with \( x \):
  \begin{align*}
    v_a^\xi(\eta) \coloneqq \begin{cases}
      a,    &\eta = \xi, \\
      v(\eta), &\eta \neq \xi.
    \end{cases}
  \end{align*}

  Inductively,
  \begin{equation*}
    v_{x_1, \ldots, x_n}^{\xi_1, \ldots, \xi_n}(\eta) \coloneqq ((v_{x_1}^{\xi_1})_{x_2}^{\xi_2})\cdots_{x_n}^{\xi_n}.
  \end{equation*}

  This allows us to define semantics for all terms:
  \begin{align*}
    \tau[v] \coloneqq \begin{cases}
      v(\xi),                               &\tau = \xi \in \Cat{Var}_{\Cal{L}}, \\
      I(f)(\tau_1[v], \ldots, \tau_n[v]),   &\tau = f(\tau_1, \ldots, \tau_n).
    \end{cases}
  \end{align*}
  and all formulas:
  \begin{align*}
    \varphi[v] \coloneqq \begin{cases}
      T,                                                &\varphi = \top, \\
      F,                                                &\varphi = \bot, \\
      (\tau_1[v], \tau_2[v]) \in I(\doteq),             &\varphi = (\tau_1 \doteq \tau_2), \\
      (\tau_1[v], \ldots, \tau_n[v]) \in I(p),          &\varphi = p(\tau_1, \ldots, \tau_n), \\
      H_\neg(\psi[v]),                                  &\varphi = \neg \psi, \\
      H_\circ(\psi_1[v], \psi_2[v]),                    &\varphi = \psi_1 \circ \psi_2, \circ \in \Sigma, \\
      \text{for all } x \in A, \psi[v_x^\xi] = T,       &\varphi = \forall \xi \psi, \\
      \text{there exists } x \in A: \psi[v_x^\xi] = T,  &\varphi = \exists \xi \psi.
    \end{cases}
  \end{align*}

  If \( \varphi[v] = T \), we say that \( \varphi \) is \Def{true under the evaluation} \( v \) in \( \Cal{A} \) and we write \( \Cal{A} \models_v \varphi \). If \( \varphi \) is true in \( \Cal{A} \) under every evaluation, we say that \( \varphi \) is \Def{true} or \Def{valid} in \( \Cal{A} \) and we write \( \Cal{A} \models \varphi \).

  Given a formula \( \varphi(\xi_1, \ldots, \xi_n) \), we write
  \begin{equation*}
    \varphi[x_1, \ldots, x_n] \coloneqq \varphi(\xi_1, \ldots, \xi_n)[v_{x_1, \ldots, x_n}^{\xi_1, \ldots, \xi_n}].
  \end{equation*}

  We also apply this notation for terms.
\end{definition}

\begin{definition}\label{def:first_order_model}\cite[28]{Lectures:logic_programming}
  A \Def{model} for a first-order theory \( \Gamma \) in the first-order language \( \Cal{L} \) is a structure \( \Cal{A} \) such that there exists a single evaluation \( v \) so that for every formula \( \gamma \in \Gamma \), we have \( \Cal{A} \models_v \gamma \). We write \( \Cal{A} \models_v \Gamma \) or simply \( \Cal{A} \models \Gamma \).

  If \( \varphi \) is any formula, we say that \( \Gamma \) \Def{entails} \( \varphi \) and write \( \Gamma \models \varphi \) if any model for \( \Gamma \) is a model for \( \varphi \).
\end{definition}

\begin{definition}\label{def:first_order_consistency}
  A first-order theory is \Def{consistent} if, under any evaluation in any structure, every formula is either true or false.
\end{definition}

\begin{proposition}\label{thm:first_order_equality_is_equivalence_relation}
  In a first-order language with equality, the equality is an equivalence relation\Tinyref{def:order/equivalence}, that is, for any structure\Tinyref{def:first_order_structure} \( \Cal{A} \), we have
  \begin{description}
    \DItem{thm:first_order_equality_is_equivalence_relation/reflexivity}[reflexivity] \( \Cal{A} \models \forall \xi (\xi \doteq \xi) \)
    \DItem{thm:first_order_equality_is_equivalence_relation/symmetry}[symmetry] \( \Cal{A} \models \forall \xi \forall \eta ((\xi \doteq \eta) \iff (\eta \doteq \xi)) \)
    \DItem{thm:first_order_equality_is_equivalence_relation/transitivity}[transitivity] \( \Cal{A} \models \forall \xi \forall \eta \forall \zeta (((\xi \doteq \eta) \land (\eta \doteq \xi)) \implies (\xi \doteq \zeta)) \)
  \end{description}
\end{proposition}
\begin{proof}
  Let \( \Cal{A} = (A, I) \) be a structure and let \( v: A \to \{ T, F \} \) be an evaluation function\Tinyref{def:first_order_evaluation}. Then

  \begin{description}
    \RItem{thm:first_order_equality_is_equivalence_relation/reflexivity} The evaluation \( (\forall \xi (\xi \doteq \xi))[v] \) is true if and only if for every \( a \in A \), we have
    \begin{equation*}
      (\xi \doteq \xi)[v_x^a] = T.
    \end{equation*}

    By \cref{remark:first_order_equality/reflexivity}, \( (\eta \doteq \eta) \) is an axiom for every \( \eta \in \Cat{Var}_{\Cal{L}} \), hence \mbox{\( (\xi \doteq \xi)[v_x^a] = T \)} for all \( a \in A \).We conclude that
    \begin{equation*}
      \Cal{A} \models_v \forall \xi (\xi \doteq \xi).
    \end{equation*}

    \RItem{thm:first_order_equality_is_equivalence_relation/symmetry} Let \( a, b \in A \) be arbitrary. Since \( (\xi \doteq \xi) \) is an axiom for every \( \xi \in \Cat{Var} \), from \cref{remark:first_order_equality/equality} we obtain
    \begin{align*}
      T &=
      (((\xi \doteq \xi) \land (\xi \doteq \eta)) \implies ((\xi \doteq \xi) \iff (\eta \doteq \xi)))[v_{\xi,\eta}^{a,b}]
      = \\ &=
      H_\Rightarrow(H_\land((\xi \doteq \xi)[v_{\xi,\eta}^{a,b}], (\xi \doteq \eta)[v_{\xi,\eta}^{a,b}]), H_\Leftrightarrow((\xi \doteq \xi)[v_{\xi,\eta}^{a,b}], (\eta \doteq \xi)[v_{\xi,\eta}^{a,b}]))
      = \\ &=
      H_\Rightarrow(H_\land(T, (\xi \doteq \eta)[v_{\xi,\eta}^{a,b}]), H_\Leftrightarrow(T, (\eta \doteq \xi)[v_{\xi,\eta}^{a,b}]))
      = \\ &=
      H_\Leftrightarrow((\xi \doteq \eta)[v_{\xi,\eta}^{a,b}], (\eta \doteq \xi)[v_{\xi,\eta}^{a,b}])
      = \\ &=
      ((\xi \doteq \eta) \iff (\eta \doteq \xi))[v_{\xi,\eta}^{a,b}].
    \end{align*}

    Both \( a \) and \( b \) were arbitrary, hence
    \begin{equation*}
      \Cal{A} \models_v \forall \xi \forall \eta ((\xi \doteq \eta) \iff (\eta \doteq \xi)).
    \end{equation*}

    \RItem{thm:first_order_equality_is_equivalence_relation/transitivity} Analogously to \ref{def:order/equivalence/symmetry}, let \( a, b, c \in A \). From \cref{remark:first_order_equality/equality} we obtain
    \begin{align*}
      T &=
      (((\xi \doteq \eta) \land (\zeta \doteq \eta)) \implies ((\xi \doteq \zeta) \iff (\eta \doteq \eta)))[v_{\xi,\eta,\zeta}^{a,b,c}]
      = \\ &=
      H_\Rightarrow(H_\land((\xi \doteq \eta)[v_{\xi,\eta,\zeta}^{a,b,c}], (\zeta \doteq \eta)[v_{\xi,\eta,\zeta}^{a,b,c}]), H_\Leftrightarrow((\xi \doteq \zeta)[v_{\xi,\eta,\zeta}^{a,b,c}], (\eta \doteq \eta)[v_{\xi,\eta,\zeta}^{a,b,c}]))
      = \\ &=
      H_\Rightarrow(H_\land((\xi \doteq \eta)[v_{\xi,\eta,\zeta}^{a,b,c}], (\zeta \doteq \eta)[v_{\xi,\eta,\zeta}^{a,b,c}]), H_\Leftrightarrow((\xi \doteq \zeta)[v_{\xi,\eta,\zeta}^{a,b,c}], T))
      = \\ &=
      H_\Rightarrow(H_\land((\xi \doteq \eta)[v_{\xi,\eta,\zeta}^{a,b,c}], (\zeta \doteq \eta)[v_{\xi,\eta,\zeta}^{a,b,c}]), (\xi \doteq \zeta)[v_{\xi,\eta,\zeta}^{a,b,c}]))
      = \\ &=
      (((\xi \doteq \eta) \land (\zeta \doteq \eta)) \implies (\xi \doteq \zeta))[v_{\xi,\eta,\zeta}^{a,b,c}].
    \end{align*}

    The values \( a \), \( b \) and \( c \) were arbitrary, hence
    \begin{equation*}
      \Cal{A} \models_v \forall \xi \forall \eta \forall \zeta (((\xi \doteq \eta) \land (\zeta \doteq \eta)) \implies (\xi \doteq \zeta)).
    \end{equation*}
  \end{description}
\end{proof}

\begin{definition}\label{def:first_order_definability}
  Fix a first-order language and structure \( \Cal{A} = (A, I) \). We say that the set \( B \subseteq A^n \) is \Def{definable} using the formula \( \varphi(\xi_1, \ldots, \xi_n) \) if
  \begin{equation*}
    \varphi[x_1, \ldots, x_n] = T \text{ if and only if } (x_1, \ldots, x_n) \in B
  \end{equation*}
\end{definition}

\begin{definition}\label{def:first_order_equation}
  An first-order \Def{equation} is an equality proposition, i.e. a proposition of the form
  \begin{equation*}
    \tau(\xi_1, \ldots, \xi_n) \doteq \rho(\xi_1, \ldots, \xi_n),
  \end{equation*}
  where both \( \tau(\xi_1, \ldots, \xi_n) \) and \( \rho(\xi_1, \ldots, \xi_n) \) are terms with the same free variables.

  Given a structure \( \Cal{A} = (A, I) \), we call the elements of the set defined by this formula \Def{solutions}. That is, we say that the tuple \( (x_1, \ldots, x_n) \) is a solution to the equation if
  \begin{equation*}
    \tau[x_1, \ldots, x_n] = \rho[x_1, \ldots, x_n]
  \end{equation*}
\end{definition}

\begin{remark}\label{remark:equations}
  A remarkable portion of mathematics concerns the study of different types of equations (even though they are not usually restricted to equations in first-order logic):

  \begin{itemize}
    \item Linear algebra (see \cref{subsec:vector_spaces} and \cref{subsec:matrices}) can be regarded as the study of linear equations.
    \item Linear functional analysis (see most of \cref{sec:analysis}) can be regarded as the study of equations relating linear operators.
    \item Differential equations (see \cref{sec:diffeq}) is aptly named since it studies equations in functional spaces concerning functions and their derivatives.
    \item Zeroes of generalized derivatives are studies in optimization.
    \item Fixed points of functions are studied in different branches of mathematics.
    \item Diophantine equations are studied in number theory.
    \item Integral equations are analogous to differential equations but concert integrals rather than derivatives.
    \item Affine varieties, which are sets of simultaneous zeroes of polynomial ideals, are studied in algebraic geometry.
  \end{itemize}
\end{remark}

\begin{definition}\label{def:first_order_homomorphism}\cite[35]{Lectures:logic_programming}
  Let \( \Cal{A} = (A, I_{\Cal{A}}) \) and \( \Cal{B} = (B, I_{\Cal{B}}) \) be structures over a common language. We say that the function\Tinyref{def:function} \( \varphi: A \to B \) is a \Def{homomorphism} between \( \Cal{A} \) and \( \Cal{B} \) if it preserves all functions and relations, that is, for any \( f \in \Cat{Func} \) and any \( x_1, \ldots, x_{\#f} \in A \),
  \begin{equation*}
    \varphi(f_{\Cal{A}}[x_1, \ldots, x_{\#f}]) = f_{\Cal{B}}[\varphi(x_1), \ldots, \varphi(x_{\#f})]
  \end{equation*}
  and for any \( p \in \Cat{Pred} \) and any \( x_1, \ldots, x_{\#p} \in A \),
  \begin{equation*}
    (x_1, \ldots, x_{\#p}) \in p_{\Cal{A}} \text{ if and only if } (\varphi(x_1), \ldots, \varphi(x_{\#p})) \in p_{\Cal{B}}.
  \end{equation*}

  We say that the homomorphism \( \varphi: A \to B \) is
  \begin{defenum}
    \DItem{def:first_order_homomorphism/embedding} an \Def{embedding} or \Def{monomorphism} if \( \varphi \) is an injective function\Tinyref{def:function_invertibility/injection}.

    \DItem{def:first_order_homomorphism/projection} a \Def{projection} or \Def{epimorphism} if \( \varphi \) is a surjective function\Tinyref{def:function_invertibility/surjection}.

    \DItem{def:first_order_homomorphism/isomorphism} an \Def{isomorphism} if \( \varphi \) is a bijective function\Tinyref{def:function_invertibility/bijection}.

    \DItem{def:first_order_homomorphism/endomorphism} an \Def{endomorphism} if \( A = B \) and an \Def{automorphism} if \( \varphi \) is a bijective endomorphism.
  \end{defenum}

  Homomorphism between first-order structures are a direct generalization of homomorphisms in algebra (see \cref{def:algebraic_theory}) and the terminology in \cref{def:morphism_invertibility} is inspired by homomorphisms.
\end{definition}

\begin{proposition}\label{thm:first_order_homomorphism_properties}
  The following are some basic properties of structure homomorphisms\Tinyref{def:first_order_homomorphism}:
  \begin{defenum}
    \DItem{thm:first_order_homomorphism_properties/substructure} If \( \Cal{A} = (A, I) \) is a structure and \( \Cal{A'} = (A', I) \) is a substructure\Tinyref{def:first_order_structure/substructure} of \( \Cal{A} \), then the projection \( \pi: A' \to A \) is an epimorphism\Tinyref{def:first_order_homomorphism/projection}.

    \DItem{thm:first_order_homomorphism_properties/preserves_substructures} If \( \Cal{A} = (A, I_{\Cal{A}}) \) and \( \Cal{B} = (B, I_{\Cal{B}}) \) are structures and \( \varphi: A \to B \) is a homomorphism, then the image\Tinyref{def:function} \( \varphi(\Cal{A}) = (\varphi(A), I_{\Cal{B}}) \) is a substructure of \( \Cal{B} \).

    \DItem{thm:first_order_homomorphism_properties/composition} The composition\Tinyref{def:function_composition} of two homomorphisms is again a homomorphism.
  \end{defenum}
\end{proposition}

\begin{proposition}\label{thm:first_order_homomorphism_preserves_models}\cite[38]{Lectures:logic_programming}
  Let \( \Cal{A} = (A, I_{\Cal{A}}) \) and \( \Cal{B} = (B, I_{\Cal{B}}) \) be structures over a common language. Let \( \varphi: A \to B \) be a homomorphism between them. Let \( \Gamma \) be a set of formulas.

  If \( \Cal{A} \models \Gamma \), then its image \( \varphi(\Cal{A}) \models \Gamma \).
\end{proposition}

\begin{definition}\label{def:first_order_model_category}
  Let \( \Cal{L} \) be a first-order language\Tinyref{def:first_order_language} and let \( \Gamma \) be a set of formulas. We denote by \( \Cat{Model}_\Gamma \) the category\Tinyref{def:category} where
  \begin{itemize}
    \item the class\Tinyref{def:set_zfc} of objects is the class of all models for \( \Gamma \)\Tinyref{def:first_order_model}.
    \item the morphisms between two models are the homomorphisms between them.
  \end{itemize}

  We define the forgetful functor
  \begin{align*}
    &U: \Cat{Model}_\Gamma \to \Bold{Set} \\
    &U((A, I)) \coloneqq A \\
    &U(f: A \to B) \coloneqq f.
  \end{align*}

  The image \( U(\Cat{Model}_\Gamma) \) is a subcategory of \( \Bold{Set} \), which implies that \( \Bold{Model}_\Gamma \) is locally small\Tinyref{def:category_cardinality} and concrete\Tinyref{def:concrete_category}.
\end{definition}
\begin{proof}
  \Cref{thm:module_homomorphism_properties/composition} shows that the composition of two homomorphisms is indeed a homomorphism and \cref{thm:first_order_homomorphism_preserves_models} shows that the image under a homomorphism of a model for \( \Gamma \) is again a model for \( \Gamma \).
\end{proof}
