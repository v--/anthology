\subsection{Grammars}\label{subsec:grammars}

\begin{definition}\label{def:grammar}\cite[definition 2.2]{Sipser2013}
  Let \( \Cal{A} \) be some alphabet\Tinyref{def:language} and \( V, \Sigma \subseteq \Cal{A} \) be nonempty disjoint subsets of \( \Cal{A} \). We call elements of \( V \) \textbf{variables} and the elements of \( \Sigma \) \textbf{terminals}. Fix special \textbf{start symbol} \( S \in V \).

  We define a binary relation\Tinyref{def:relation} \( \to \) of \textbf{production rules} over \( (V \cup \Sigma)^* \), that is, rules are \enquote{transformations} that define how a language is \enquote{generated} starting from \( S \in V \) (see \cref{def:grammar_derivation} and \cref{ex:context_free_grammar/real_arithmetic}). As a shortcut, instead of listing individual rules with the same source as
  \begin{align*}
    &u \to v, \\
    &u \to w,
  \end{align*}
  we write
  \begin{equation*}
    u \to v | w.
  \end{equation*}

  Rules of the form \( u \to \sigma \) where \( \sigma \in \Sigma \) are called \textbf{terminal rules}.

  We call the tuple \( G \coloneqq (V, \Sigma, R, S) \) a \textbf{formal grammar}. If every production rule has only a single variable for a source, we say that the grammar is a \textbf{context-free grammar}.
\end{definition}

\begin{remark}\label{note:grammar_symbol_case}
  It is a common convention to denote variables with uppercase letters and terminals with lowercase letters. Lowercase letters are also used, however, for words in \( (V \cup \Sigma)^* \).
\end{remark}

\begin{definition}\label{def:grammar_derivation}\cite[104,108]{Sipser2013}
  Fix a word \( pvs \) (\enquote{\( p \)} stands for \enquote{prefix} and \enquote{\( s \)} stands for \enquote{suffix}). If \( u \to v \) is a production rule, we say that \( pvs \) \textbf{yields} the word \( pws \) and write \( pvs \implies pws \).

  We say that \textbf{\( u \) derives \( v \)} and write \( u \Derives v \) if there exists a finite sequence of words \( u_1, \ldots, u_n \) such that
  \begin{equation*}
    u \implies u_1 \implies \ldots \implies u_n \implies v.
  \end{equation*}

  If on every step of the derivation the leftmost (resp. rightmost) variable is replaced, we say that it is a \textbf{leftmost (resp. rightmost) derivation}.

  Define the \textbf{language of the grammar} to be
  \begin{equation*}
    \Cal{L}(G) \coloneqq \{ w \in \Sigma^* \colon S \implies w \},
  \end{equation*}
  that is, all words that can be derived from \( S \) and contains only terminals.

  We also say that strings in \( \Cal{L}(G) \) are \textbf{generated by the grammar \( G \)}.
\end{definition}

\begin{definition}\label{def:ambiguous_grammar}\cite[definition 2.7]{Sipser2013}
  Let \( G \) be a grammar. We say that the word \( w \) can be derived \textbf{unambiguously} if there exists a unique leftmost derivation from \( S \). Otherwise we say that \( w \) is generated \textbf{ambiguously} and that the grammar itself is \textbf{ambiguous}.
\end{definition}

\begin{example}\label{ex:context_free_grammar/real_arithmetic}
  We will define a grammar for addition on natural numbers\Tinyref{def:natural_numbers_zfc}. Note that we only consider the number in \( \BB{N} \) only as symbols, not as the numbers themselves.

  Let \( V \coloneqq \{ A \} \) and \( \Sigma \coloneqq \BB{N} \cup \{ +, \cdot, (, ) \} \). Define the rules:
  \begin{itemize}
    \item for each natural number \( n \), define the rule \( A \to n \).
    \item \( A \to (A + A) \)
  \end{itemize}

  Choose the starting symbol to be the only symbol \( x \) in \( V \). Then the grammar can produce the arithmetic expression \( ((1 + 2) + 3) \) by applying the rules
  \begin{equation*}
    \begin{mplibcode}
      u := 2cm;

      beginfig(1);
        input metapost/graphs;

        v1 := thelabel("$A$", origin);
        v2 := thelabel("$(A + A)$", (0, -1) scaled u);
        v3 := thelabel("$3$", (1, -2) scaled u);
        v4 := thelabel("$(A + A)$", (-1, -2) scaled u);
        v5 := thelabel("$1$", (-2, -3) scaled u);
        v6 := thelabel("$2$", (0, -3) scaled u);

        a1 := straight_arc(v1, v2);
        a2 := straight_arc(v2, v3);
        a3 := straight_arc(v2, v4);
        a4 := straight_arc(v4, v5);
        a5 := straight_arc(v4, v6);

        draw_vertices(v);
        draw_arcs(a);

        label.lft("$A \to (A + A$)", straight_arc_midpoint of a1);
        label.urt("$A \to 3$", straight_arc_midpoint of a2);
        label.ulft("$A \to (A + A)$", straight_arc_midpoint of a3);
        label.ulft("$A \to 1$", straight_arc_midpoint of a4);
        label.urt("$A \to 2$", straight_arc_midpoint of a5);
      endfig;
    \end{mplibcode}
  \end{equation*}

  Note that the grammar is unambiguous because of the parentheses. If we omit the parentheses, it will no longer be unambiguous since \( 1 + 2 + 3 \) can be derived by both
  \begin{equation*}
    \begin{mplibcode}
      u := 2cm;

      beginfig(1);
        input metapost/graphs;

        v1 := thelabel("$A$", origin);
        v2 := thelabel("$A + A$", (0, -1) scaled u);
        v3 := thelabel("$1$", (-1, -2) scaled u);
        v4 := thelabel("$A + A$", (1, -2) scaled u);
        v5 := thelabel("$2$", (0, -3) scaled u);
        v6 := thelabel("$3$", (2, -3) scaled u);

        a1 := straight_arc(v1, v2);
        a2 := straight_arc(v2, v3);
        a3 := straight_arc(v2, v4);
        a4 := straight_arc(v4, v5);
        a5 := straight_arc(v4, v6);

        draw_vertices(v);
        draw_arcs(a);

        label.lft("$A \to A + A$", straight_arc_midpoint of a1);
        label.ulft("$A \to 1$", straight_arc_midpoint of a2);
        label.urt("$A \to A + A$", straight_arc_midpoint of a3);
        label.ulft("$A \to 2$", straight_arc_midpoint of a4);
        label.urt("$A \to 3$", straight_arc_midpoint of a5);
      endfig;
    \end{mplibcode}
    \hspace{1cm}
    \begin{mplibcode}
      u := 2cm;

      beginfig(1);
        input metapost/graphs;

        v1 := thelabel("$A$", origin);
        v2 := thelabel("$A + A$", (0, -1) scaled u);
        v3 := thelabel("$3$", (1, -2) scaled u);
        v4 := thelabel("$A + A$", (-1, -2) scaled u);
        v5 := thelabel("$1$", (-2, -3) scaled u);
        v6 := thelabel("$2$", (0, -3) scaled u);

        a1 := straight_arc(v1, v2);
        a2 := straight_arc(v2, v3);
        a3 := straight_arc(v2, v4);
        a4 := straight_arc(v4, v5);
        a5 := straight_arc(v4, v6);

        draw_vertices(v);
        draw_arcs(a);

        label.lft("$A \to A + A$", straight_arc_midpoint of a1);
        label.urt("$A \to 3$", straight_arc_midpoint of a2);
        label.ulft("$A \to A + A$", straight_arc_midpoint of a3);
        label.ulft("$A \to 1$", straight_arc_midpoint of a4);
        label.urt("$A \to 2$", straight_arc_midpoint of a5);
      endfig;
    \end{mplibcode}
  \end{equation*}
\end{example}
\begin{proof}
  We will show that \( G \) is unambiguous. Let \( w \) be a word in \( \Cal{L}(G) \). We explicitly build the derivation of \( w \):
  \begin{itemize}
    \item If \( \Len(w) = 1 \), then \( w \in \BB{N} \) and the word has been generated by the single rule \( A \to w \).
    \item If \( \Len(w) > 1 \), then \( w \) is necessarily enclosed in parentheses. Let \( w = ( \sigma_0 \ldots \sigma_m ) \) be the symbols of \( w \). Because of the parentheses, the only possibility for \( \sigma_0 \ldots \sigma_m \) is that it consists of two words in \( \Cal{L}(G) \) with an operation symbol \( \circ \in \{ +, \cdot \} \) between them. Let \( k \) be the index of the operator, that is, the index such that \( \sigma_1 \ldots \sigma_{k-1} \) and \( \sigma_{k+1} \ldots \sigma_m \) both belong to \( \Cal{L}(G) \).

    The derivation of \( w \) is then given by \( A \to (A \sigma_k A) \), followed by applying the same algorithm to the word \( \sigma_1 \ldots \sigma_{k-1} \), followed by applying the same algorithm to the word \( \sigma_1 \ldots \sigma_{k+1} \).
  \end{itemize}
\end{proof}
