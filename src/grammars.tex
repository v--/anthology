\subsection{Grammars}\label{subsec:grammars}

\begin{definition}\label{def:grammar}\MarginCite[def. 2.2]{Sipser2013}
  Let \( \Cal{A} \) be some \hyperref[def:language]{alphabet} and \( V, \Sigma \subseteq \Cal{A} \) be nonempty disjoint subsets of \( \Cal{A} \). We call elements of \( V \) \Def{variables} and the elements of \( \Sigma \) \Def{terminals}. Fix special \Def{start symbol} \( S \in V \).

  We define a binary \hyperref[def:relation]{relation} \( \to \) of \Def{production rules} over \( (V \cup \Sigma)^* \), that is, rules are \enquote{transformations} that define how a language is \enquote{generated} starting from \( S \in V \) (see \fullref{def:grammar_derivation} and \fullref{ex:context_free_grammar/real_arithmetic}). As a shortcut, instead of listing individual rules with the same source as
  \begin{BreakableAlign*}
     & u \to v, \\
     & u \to w,
  \end{BreakableAlign*}
  we write
  \begin{equation*}
    u \to v | w.
  \end{equation*}

  Rules of the form \( u \to \sigma \), where \( \sigma \in \Sigma \), are called \Def{terminal rules}.

  We call the tuple \( G \coloneqq (V, \Sigma, R, S) \) a \Def{formal grammar}. If every production rule has only a single variable for a source, we say that the grammar is a \Def{context-free grammar}.
\end{definition}

\begin{remark}\label{remark:grammar_symbol_case}
  It is a common convention to denote variables with uppercase letters and terminals with lowercase letters. Lowercase letters are also used, however, for words in \( (V \cup \Sigma)^* \).
\end{remark}

\begin{definition}\label{def:grammar_derivation}\MarginCite[104,108]{Sipser2013}
  Fix a word \( pvs \) (all \( p \), \( v \) and \( s \) are subwords of \( pvs \); \enquote{\( p \)} stands for \enquote{prefix} and \enquote{\( s \)} stands for \enquote{suffix}). If \( u \to v \) is a production rule, we say that \( pvs \) \Def{yields} the word \( pws \) and write \( pvs \implies pws \).

  We say that \( u \) \Def{derives} \( v \) and write \( u \Derives v \) if there exists a finite sequence of words \( u_1, \ldots, u_n \) such that
  \begin{equation*}
    u \implies u_1 \implies \ldots \implies u_n \implies v.
  \end{equation*}

  If on every step of the derivation the leftmost (resp. rightmost) variable is replaced, we say that it is a \Def{leftmost} (resp. \Def{rightmost}) derivation.

  Define the \Def{language of the grammar} to be
  \begin{equation*}
    \Cal{L}(G) \coloneqq \{ w \in \Sigma^* \colon S \Derives w \},
  \end{equation*}
  that is, all words that can be derived from \( S \) and contains only terminals.

  We also say that strings in \( \Cal{L}(G) \) are \Def{generated} by the grammar \( G \).
\end{definition}

\begin{definition}\label{def:ambiguous_grammar}\MarginCite[def. 2.7]{Sipser2013}
  Let \( G \) be a grammar. We say that the word \( w \) can be derived \Def{unambiguously} if there exists a unique leftmost derivation from \( S \). Otherwise we say that \( w \) is generated \Def{ambiguously} and that the grammar itself is \Def{ambiguous}.
\end{definition}

\begin{example}\label{ex:context_free_grammar/real_arithmetic}
  We will define a grammar for addition on \hyperref[def:natural_numbers]{natural numbers}. Note that we only consider the number in \( \BN \) only as symbols, not as the numbers themselves.

  Let \( V \coloneqq \{ A \} \) and \( \Sigma \coloneqq \BN \cup \{ +, (, ) \} \). Define the rules:
  \begin{itemize}
    \item for each natural number \( n \), define the rule \( A \to n \).
    \item \( A \to (A + A) \)
  \end{itemize}

  Choose the starting symbol to be the only symbol \( A \) in \( V \). Then the grammar can produce the arithmetic expression \( ((1 + 2) + 3) \) by applying the rules
  \begin{equation*}
    \begin{mplibcode}
      u := 2cm;

      beginfig(1);
      input metapost/graphs;

      v1 := thelabel("$A$", origin);
      v2 := thelabel("$(A + A)$", (0, -1) scaled u);
      v3 := thelabel("$3$", (1, -2) scaled u);
      v4 := thelabel("$(A + A)$", (-1, -2) scaled u);
      v5 := thelabel("$1$", (-2, -3) scaled u);
      v6 := thelabel("$2$", (0, -3) scaled u);

      a1 := straight_arc(v1, v2);
      a2 := straight_arc(v2, v3);
      a3 := straight_arc(v2, v4);
      a4 := straight_arc(v4, v5);
      a5 := straight_arc(v4, v6);

      draw_vertices(v);
      draw_arcs(a);

      label.lft("$A \to (A + A$)", straight_arc_midpoint of a1);
      label.urt("$A \to 3$", straight_arc_midpoint of a2);
      label.ulft("$A \to (A + A)$", straight_arc_midpoint of a3);
      label.ulft("$A \to 1$", straight_arc_midpoint of a4);
      label.urt("$A \to 2$", straight_arc_midpoint of a5);
      endfig;
    \end{mplibcode}
  \end{equation*}

  Note that the grammar is unambiguous because of the parentheses. If we omit the parentheses, it will no longer be unambiguous since \( 1 + 2 + 3 \) can be derived by both
  \begin{equation*}
    \begin{mplibcode}
      u := 2cm;

      beginfig(1);
      input metapost/graphs;

      v1 := thelabel("$A$", origin);
      v2 := thelabel("$A + A$", (0, -1) scaled u);
      v3 := thelabel("$1$", (-1, -2) scaled u);
      v4 := thelabel("$A + A$", (1, -2) scaled u);
      v5 := thelabel("$2$", (0, -3) scaled u);
      v6 := thelabel("$3$", (2, -3) scaled u);

      a1 := straight_arc(v1, v2);
      a2 := straight_arc(v2, v3);
      a3 := straight_arc(v2, v4);
      a4 := straight_arc(v4, v5);
      a5 := straight_arc(v4, v6);

      draw_vertices(v);
      draw_arcs(a);

      label.lft("$A \to A + A$", straight_arc_midpoint of a1);
      label.ulft("$A \to 1$", straight_arc_midpoint of a2);
      label.urt("$A \to A + A$", straight_arc_midpoint of a3);
      label.ulft("$A \to 2$", straight_arc_midpoint of a4);
      label.urt("$A \to 3$", straight_arc_midpoint of a5);
      endfig;
    \end{mplibcode}
    \hspace{1cm}
    \begin{mplibcode}
      u := 2cm;

      beginfig(1);
      input metapost/graphs;

      v1 := thelabel("$A$", origin);
      v2 := thelabel("$A + A$", (0, -1) scaled u);
      v3 := thelabel("$3$", (1, -2) scaled u);
      v4 := thelabel("$A + A$", (-1, -2) scaled u);
      v5 := thelabel("$1$", (-2, -3) scaled u);
      v6 := thelabel("$2$", (0, -3) scaled u);

      a1 := straight_arc(v1, v2);
      a2 := straight_arc(v2, v3);
      a3 := straight_arc(v2, v4);
      a4 := straight_arc(v4, v5);
      a5 := straight_arc(v4, v6);

      draw_vertices(v);
      draw_arcs(a);

      label.lft("$A \to A + A$", straight_arc_midpoint of a1);
      label.urt("$A \to 3$", straight_arc_midpoint of a2);
      label.ulft("$A \to A + A$", straight_arc_midpoint of a3);
      label.ulft("$A \to 1$", straight_arc_midpoint of a4);
      label.urt("$A \to 2$", straight_arc_midpoint of a5);
      endfig;
    \end{mplibcode}
  \end{equation*}
\end{example}
\begin{proof}
  We will show that \( G \) is unambiguous. Let \( w \) be a word in \( \Cal{L}(G) \). We explicitly build the derivation of \( w \):
  \begin{itemize}
    \item If \( \Len(w) = 1 \), then \( w = n \in \BN \) and the word has been generated by the single rule \( A \to n \).
    \item If \( \Len(w) > 1 \), then \( w \) is necessarily enclosed in parentheses. Let \( w = ( \sigma_0 \ldots \sigma_m ) \) be the symbols of \( w \). Because of the parentheses, the only possibility for \( \sigma_0 \ldots \sigma_m \) is that it consists of two words in \( \Cal{L}(G) \) with an addition symbol \( + \) between them. Let \( k \) be the index of the operator, that is, the index such that \( \sigma_1 \ldots \sigma_{k-1} \) and \( \sigma_{k+1} \ldots \sigma_m \) both belong to \( \Cal{L}(G) \).

          The derivation of \( w \) is then given by \( A \to (A \sigma_k A) \), followed by applying the same algorithm to the word \( \sigma_1 \ldots \sigma_{k-1} \), followed by applying the same algorithm to the word \( \sigma_1 \ldots \sigma_{k+1} \).
  \end{itemize}
\end{proof}
