\section{Grammars}\label{sec:grammars}

\begin{definition}\label{def:grammar}\cite[definition 2.2]{Sipser2013}
  Let $\Cal{A}$ be some alphabet\Tinyref{def:language} and $V, \Sigma \subseteq \Cal{A}$ be nonempty disjoint subsets of $\Cal{A}$. We call elements of $V$ \underLine{variables} and the elements of $\Sigma$ \underLine{terminals}. Fix special \underLine{start symbol} $S \in V$.

  We define a binary relation\Tinyref{def:relation} $\to$ of \underLine{production rules} over $(V \cup \Sigma)^*$, that is, rules are \enquote{transformations} that define how a language is \enquote{generated} starting from $S \in V$ (see \cref{def:grammar_derivation} and \cref{ex:context_free_grammar/real_arithmetic}). As a shortcut, instead of listing individual rules with the same source as
  \begin{align*}
    &u \to v, \\
    &u \to w,
  \end{align*}
  we write
  \begin{align*}
    u \to v | w.
  \end{align*}

  Rules of the form $u \to \sigma$ where $\sigma \in \Sigma$ are called \underLine{terminal rules}.

  We call the tuple $G \coloneqq (V, \Sigma, R, S)$ a \underLine{formal grammar}. If every production rule has only a single variable for a source, we say that the grammar is a \underLine{context-free grammar}.
\end{definition}

\begin{note}\label{note:grammar_symbol_case}
  It is a common convention to denote variables with uppercase letters and terminals with lowercase letters. Lowercase letters are also used, however, for words in $(V \cup \Sigma)^*$.
\end{note}

\begin{definition}\label{def:grammar_derivation}\cite[104,108]{Sipser2013}
  Fix a word $pvs$ (\enquote{$p$} stands for \enquote{prefix} and \enquote{$s$} stands for \enquote{suffix}). If $u \to v$ is a production rule, we say that $pvs$ \underLine{yields} the word $pws$ and write $pvs \implies pws$.

  We say that \underLine{$u$ derives $v$} and write $u \Derives v$ if there exists a finite sequence of words $u_1, \ldots, u_n$ such that
  \begin{align*}
    u \implies u_1 \implies \ldots \implies u_n \implies v.
  \end{align*}

  If on every step of the derivation the leftmost (resp. rightmost) variable is replaced, we say that it is a \underLine{leftmost (resp. rightmost) derivation}.

  Define the \underLine{language of the grammar} to be
  \begin{align*}
    \Cal{L}(G) \coloneqq \{ w \in \Sigma^* \colon S \implies w \},
  \end{align*}
  that is, all words that can be derived from $S$ and contains only terminals.

  We also say that strings in $\Cal{L}(G)$ are \underLine{generated by the grammar $G$}.
\end{definition}

\begin{definition}\label{def:ambiguous_grammar}\cite[definition 2.7]{Sipser2013}
  Let $G$ be a grammar. We say that the word $w$ can be derived \underLine{unambiguously} if there exists a unique leftmost derivation from $S$. Otherwise we say that $w$ is generated \underLine{ambiguously} and that the grammar itself is \underLine{ambiguous}.
\end{definition}

\begin{example}\label{ex:context_free_grammar/real_arithmetic}
  We will define a grammar for addition on natural numbers\Tinyref{def:natural_numbers_zfc}. Note that we only consider the number in $\BB{N}$ only as symbols, not as the numbers themselves.

  Let $V \coloneqq \{ A \}$ and $\Sigma \coloneqq \BB{N} \cup \{ +, \cdot, (, ) \}$. Define the rules:
  \begin{itemize}
    \item for each natural number $n$, define the rule $A \to n$.
    \item $A \to (A + A)$
  \end{itemize}

  Choose the starting symbol to be the only symbol $x$ in $V$. Then the grammar can produce the arithmetic expression $((1 + 2) + 3)$ by applying the rules
  \begin{Center}
    \begin{tikzcd}
      &                                                      & A \arrow[d, "A \to (A + A)"]                               &   \\
      &                                                      & (A + A) \arrow[ld, "A \to (A + A)"'] \arrow[rd, "A \to 3"] &   \\
      & (A + A) \arrow[ld, "A \to 1"'] \arrow[rd, "A \to 2"] &                                                            & 3 \\
    1 &                                                      & 2                                                          &
    \end{tikzcd}
  \end{Center}

  Note that the grammar is unambiguous because of the parentheses. If we omit the parentheses, it will no longer be unambiguous since $1 + 2 + 3$ can be derived by both
  \begin{Center}
    \begin{tikzcd}
      & Af \arrow[d, "A \to A + A"]                             &                                                    & \\
      & A + A \arrow[ld, "A \to 1"'] \arrow[rd, "A \to A + A"] &                                                    & \\
    1 &                                                        & A + A \arrow[ld, "A \to 2"'] \arrow[rd, "A \to 3"] & \\
      & 2                                                      &                                                    & 3
    \end{tikzcd}
    \begin{tikzcd}
      &                                                    & A \arrow[d, "A \to A + A"]                             &   \\
      &                                                    & A + A \arrow[ld, "A \to A + A"'] \arrow[rd, "A \to 3"] &   \\
      & A + A \arrow[ld, "A \to 1"'] \arrow[rd, "A \to 2"] &                                                        & 3 \\
    1 &                                                    & 2                                                      &
    \end{tikzcd}
  \end{Center}
\end{example}
\begin{proof}
  We will show that $G$ is unambiguous. Let $w$ be a word in $\Cal{L}(G)$. We explicitly build the derivation of $w$:
  \begin{itemize}
    \item If $\Len(w) = 1$, then $w \in \BB{N}$ and the word has been generated by the single rule $A \to w$.
    \item If $\Len(w) > 1$, then $w$ is necessarily enclosed in parentheses. Let $w = ( \sigma_0 \ldots \sigma_m )$ be the symbols of $w$. Because of the parentheses, the only possibility for $\sigma_0 \ldots \sigma_m$ is that it consists of two words in $\Cal{L}(G)$ with an operation symbol $\circ \in \{ +, \cdot \}$ between them. Let $k$ be the index of the operator, that is, the index such that $\sigma_1 \ldots \sigma_{k-1}$ and $\sigma_{k+1} \ldots \sigma_m$ both belong to $\Cal{L}(G)$.

    The derivation of $w$ is then given by $A \to (A \sigma_k A)$, followed by applying the same algorithm to the word $\sigma_1 \ldots \sigma_{k-1}$, followed by applying the same algorithm to the word $\sigma_1 \ldots \sigma_{k+1}$.
  \end{itemize}
\end{proof}
