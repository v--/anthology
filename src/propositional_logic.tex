\subsection{Propositional logic}\label{subsec:propositional_logic}

\begin{remark}\label{remark:metalanguage}
  Mathematical logic uses mathematics to study languages that themselves describe mathematics. Thus a distinction should be made between \Def{the language} under study, and \Def{the metalanguage} which we use to write statements relating to the language under study. This distinction is often emphasized by using different logical symbols in the two languages. We do not force such a distinction since it is often clear from the context which language the symbol belongs to.

  Outside of logic, \fullref{def:propositional_logic_language/connectives} are frequently used, however the use of connectives in statements in the metalanguage within logic can be reduced to a minimum and not cause any confusion. At the same time, \fullref{def:propositional_logic_language/constants} are used both in the language and in the metalanguage, so we use the following convention:
  \begin{itemize}
    \item the \( \top \) and \( \bot \) symbols represent truth and false values in the language.
    \item the \( T \) and \( F \) symbols represent truth and false values in the metalanguage.
  \end{itemize}

  We denote equality in the language by \( \doteq \).
\end{remark}

\begin{definition}\label{def:propositional_logic_language}\cite[102]{OpenLogic20201202}
  Propositional logic is a simple framework for describing relationships between statements. It is sometimes called boolean logic because of \fullref{thm:propositional_logic_boolean_algebra}.

  The language\Tinyref{def:language} of propositional logic consists of \Def{propositional formulas}, which are certain well-formed words over the alphabet consisting of
  \begin{description}
    \DItem{def:propositional_logic_language/prop}(propositional variables) A nonempty set \( \Cat{Prop} \) of \Def{propositional variables}.

    \DItem{def:propositional_logic_language/constants}(propositional constants)\mbox{}
    \begin{description}
      \DItem{def:propositional_logic_language/top}(top) \( \top \)
      \DItem{def:propositional_logic_language/bottom}(bottom) \( \bot \)
    \end{description}

    \DItem{def:propositional_logic_language/negation}(negation) \( \neg \)
    \DItem{def:propositional_logic_language/connectives}(propositional connectives) The set \( \Sigma \) of \Def{propositional connectives}, namely
    \begin{description}
      \DItem{def:propositional_logic_language/conjunction}(conjunction (and)) \( \land \)
      \DItem{def:propositional_logic_language/disjunction}(disjunction (or)) \( \lor \)
      \DItem{def:propositional_logic_language/implication}(implication) \( \implies \)
      \DItem{def:propositional_logic_language/equivalence}(equivalence) \( \iff \)
      \DItem{def:propositional_logic_language/pierce_arrow}(Pierce's arrow (nor)) \( \downarrow \)
      \DItem{def:propositional_logic_language/sheffer_stroke}(Sheffer stroke (nand)) \( \uparrow \)
    \end{description}

    \DItem{def:propositional_logic_language/parentheses}(parentheses) Parentheses \( ( \) and \( ) \) for defining the order of operations unambiguously (see \fullref{remark:propositional_formula_parentheses}).
  \end{description}

  The propositional formulas \( \Cal{F}_B \) are defined inductively as
  \begin{itemize}
    \item the variables in \( \Cat{Prop} \) are formulas.
    \item the constants \( \top \) and \( \bot \) are formulas.
    \item if \( \varphi \) is a formula, then \( \neg \varphi \) is a formula.
    \item if \( \varphi \) and \( \psi \) are formulas, so are \( (\varphi \circ \psi) \), where \( \circ \in \Sigma \).
  \end{itemize}

  Furthermore, the grammar of propositional formulas is unambiguous (see \fullref{thm:propositional_formulas_are_unambiguous}).

  If \( \varphi \) and \( \psi \) are formulas and \( \psi \) is a subword of \( \varphi \), we say that \( \psi \) is a \Def{subformula} of \( \varphi \).

  For each formula \( \varphi \), we define the set of its variables as
  \begin{align*}
    \Cat{Var}(\varphi) \coloneqq \begin{cases}
      \varnothing,                              &\varphi \in \{ \top, \bot \} \\
      \{ P \},                                  &\varphi = P \in \Cat{Prop} \\
      \Cat{Var}(\psi),                         &\varphi = \neg \psi \\
      \Cat{Var}(\psi) \cup \Bold{Var}(\theta), &\varphi = (\psi \circ \theta), \circ \in \Sigma.
    \end{cases}
  \end{align*}
\end{definition}

\begin{definition}\label{def:truth_functions}
  We define the following truth functions
  \begin{equation*}
    \begin{tabular}{c | c || c c | c c c c c c}
      \( x \)    & \( H_\neg \) & \( x \)    & \( y \)    & \( H_\lor \) & \( H_\land \) & \( H_\Rightarrow \) & \( H_{\iff} \) & \( H_\downarrow \) & \( H_\uparrow \) \\
      \hline
      \( T \)    & \( F \)      & \( T \)    & \( T \)    & \( T \)      & \( T \)       & \( T \)          & \( T \)      & \( F \)            & \( F \)    \\
      \( F \)    & \( T \)      & \( T \)    & \( F \)    & \( T \)      & \( F \)       & \( F \)          & \( F \)      & \( F \)            & \( T \)    \\
             &          & \( F \)    & \( T \)    & \( T \)      & \( F \)       & \( T \)          & \( T \)      & \( F \)            & \( T \)    \\
             &          & \( F \)    & \( F \)    & \( F \)      & \( F \)       & \( T \)          & \( F \)      & \( T \)            & \( T \)
    \end{tabular}
  \end{equation*}
\end{definition}

\begin{definition}\label{def:propositional_substition}
  If \( \varphi \) and \( \rho \) are formulas and \( \psi \) is a subformula of \( \varphi \), we define the \Def{substition} of \( \psi \) with \( \rho \) in \( \varphi \) as
  \begin{align*}
    \varphi[\psi \to \rho] &\coloneqq \begin{cases}
      \rho,                                                    &\varphi = \psi \\
      \varphi,                                                 &\varphi \neq \psi \text{ and } \varphi \in \{ \top, \bot \} \cup \Cat{Prop} \\
      \neg \theta[\psi \to \rho],                              &\varphi \neq \psi \text{ and } \varphi = \neg \theta \\
      (\theta_1[\psi \to \rho] \circ \theta_2[\psi \to \rho]), &\varphi \neq \psi \text{ and } \varphi = (\theta_1 \circ \theta_2), \circ \in \Sigma.
    \end{cases}
  \end{align*}

  We will now define \Def{simultaneous substition} of \( \psi_1, \ldots, \psi_n \) with \( \rho_1, \ldots, \rho_n \). The problem with iterated substition that we wish to avoid is if \( \psi_i \) is a subformula of \( \rho_{i-1} \) and accidentally gets replaced during \( \varphi[\psi_{i-1} \to \rho_{i-1}][\psi_i \to \rho_i] \).

  Define
  \begin{equation*}
    \Cat{Bound} \coloneqq \Bold{Var}(\rho_1) \cup \ldots \cup \Bold{Var}(\rho_n).
  \end{equation*}
  and, for each variable \( P_i \) in \( \Cat{Bound} \), choose\AOC a variable \( Q_i \) from \( \Bold{Prop} \setminus \Bold{Bound} \). Let \( m \) be the cardinality of \( \Bold{Bound} \). The simultaneous substitution can then be defined as
  \begin{align*}
    \varphi[\psi_1 \to \rho_1, \ldots, \psi_n \to \rho_n] \coloneqq \varphi
    [\psi_1 \to \rho_1[P_1 \to Q_1, \ldots, P_m \to Q_m]] \\
    \ldots \\
    [\psi_n \to \rho_n[P_1 \to Q_1, \ldots, P_m \to Q_m]] \\
    [Q_1 \to P_1, \ldots, Q_m \to P_m].
  \end{align*}
\end{definition}

\begin{remark}\label{remark:propositional_formula_parentheses}
  We often omit parentheses from propositional formulas when no conceptual ambiguity is possible, for example we often write \( \varphi \land \psi \land \theta \) instead of \( ((\varphi \land \psi) \land \theta) \). These are only notations shortcuts in the metalanguage\Tinyref{remark:metalanguage} and the formulas themselves (as abstract mathematical objects) are still assumed to contain parentheses to avoid syntactic ambiguity (see \fullref{thm:propositional_formulas_are_unambiguous}).
\end{remark}

\begin{proposition}\label{thm:propositional_formulas_are_unambiguous}
  The grammar\Tinyref{def:grammar} of propositional logic formulas\Tinyref{def:propositional_logic_language}
  \begin{displaymath}
    \begin{aligned}
      &\Phi \to p,                 &&p \in \Cat{Prop} \\
      &\Phi \to \top \;|\; \bot    && \\
      &\Phi \to \neg \Phi          && \\
      &\Phi \to (\Phi \circ \Phi), &&\circ \in \Sigma.
    \end{aligned}
  \end{displaymath}
  is unambiguous\Tinyref{def:ambiguous_grammar}.
\end{proposition}
\begin{proof}
  The proof is analogous to \fullref{ex:context_free_grammar/real_arithmetic}.
\end{proof}

\begin{remark}\label{remark:minimal_propositional_language}
  By \fullref{ex:posts_completeness_theorem/nand}, it is actually sufficient for propositional logic to only have
  \begin{itemize}
    \item \fullref{def:propositional_logic_language/prop}.
    \item \fullref{def:propositional_logic_language/pierce_arrow} \( \downarrow \) or the \fullref{def:propositional_logic_language/sheffer_stroke} \( \uparrow \) (we will use the arrow \( \downarrow \)).
    \item \fullref{def:propositional_logic_language/parentheses}.
  \end{itemize}

  We are able to expand the language and define the constants, negation and all other connectives so that the truth functions in \fullref{def:truth_functions} are satisfied. This can simplify the study of propositional logic itself.

  Equivalence is a bit tricky to define since we use it to define the other logical operations. We choose\AOC two variables \( P \) and \( Q \) and define an auxiliary formula that expresses the equivalence \( P \iff Q \) through Pierce's arrow:
  \begin{equation*}
    \lambda \coloneqq (P \downarrow (Q \downarrow Q)) \downarrow (Q \downarrow (P \downarrow P)).
  \end{equation*}
 or \fullref{def:algebraic_theory}
  In order to simplify our discussion, we can assume that the following axioms always hold (see \fullref{def:propositional_theory}) for all formulas \( \varphi \) and \( \psi \):
  \begin{description}
    \RItem{def:propositional_logic_language/equivalence} \( \lambda[P \to (\varphi \iff \psi), Q \to \lambda[P \to \varphi, Q \to \psi]] \)
    \RItem{def:propositional_logic_language/negation} \( \neg \varphi \iff (\varphi \downarrow \varphi) \)
    \RItem{def:propositional_logic_language/conjunction} \( (\varphi \land \psi) \iff ((\varphi \downarrow \varphi) \downarrow (\psi \downarrow \psi)) \)
    \RItem{def:propositional_logic_language/disjunction} \( (\varphi \lor \psi) \iff \neg (\varphi \downarrow \psi) \)
    \RItem{def:propositional_logic_language/top} \( \top \iff (\varphi \land \varphi) \)
    \RItem{def:propositional_logic_language/bottom} \( \bot \iff \neg \top \)
    \RItem{def:propositional_logic_language/implication} \( (\varphi \implies \psi) \iff (\neg \varphi \lor \psi) \)
    \RItem{def:propositional_logic_language/sheffer_stroke} \( (\varphi \uparrow \psi) \iff \neg (\varphi \land \psi) \)
  \end{description}

  The proofs of these equivalences can be easily verified using the truth tables in \fullref{def:truth_functions}.
\end{remark}

\begin{definition}\label{def:conjunctive_normal_form}
  We define \Def{literals} to either be propositional variables \( L = P \) or negations \( L = \neg P \) of propositional variables.

  We define \Def{disjuncts} (resp. \Def{conjuncts}) to be finite disjunctions (resp. conjunctions) of literals, i.e.
  \begin{equation*}
    L_1 \lor L_2 \lor \ldots \lor L_n.
  \end{equation*}

  We say that a propositional formula \( \varphi \) is in \Def{conjunctive normal form} (resp. \Def{disjunctive normal form}) if \( \varphi \) is a finite conjunction of disjunctions (resp. finite disjunction of conjunctions).
\end{definition}

\begin{proposition}\label{thm:conjunctive_normal_form_reduction}
  Every propositional formula \( \varphi \) is Boolean equivalent\Tinyref{def:propositional_interpretation} to a formula in conjunctive normal form\Tinyref{def:conjunctive_normal_form}.
\end{proposition}

\begin{definition}\label{def:propositional_interpretation}
  A \Def{propositional interpretation} is a function \( I: \Cat{Prop} \to \{ T, F \} \).

  We define interpretation for formulas inductively as
  \begin{align*}
    \varphi[I] \coloneqq \begin{cases}
      T,                           &\varphi = \top \\
      F,                           &\varphi = \bot \\
      I(P),                        &\varphi = P \in \Cat{Prop} \\
      H_\neg(\psi[I]),             &\varphi = \neg \psi         \\
      H_\circ(\psi[I], \theta[I]), &\varphi = \psi \circ \theta, \circ \in \Sigma.
    \end{cases}
  \end{align*}

  We say that
  \begin{defenum}
    \DItem{def:propositional_interpretation/model} \( I \) is a \Def{Boolean model} of \( \varphi \) and write \( I \models_B \varphi \) if \( \varphi[I] = T \).
    \DItem{def:propositional_interpretation/entailment} the set \( \Gamma \) of formulas \Def{entail} the formula \( \varphi \) (denoted as \( \Gamma \models_B \varphi \)) if every model for \( \Gamma \) is a model for \( \varphi \).
    \DItem{def:propositional_interpretation/tautology} \( \varphi \) is a \Def{tautology} if all interpretations are models for \( \varphi \).
    \DItem{def:propositional_interpretation/contradiction} \( \varphi \) is a \Def{contradiction} if no interpretation is a model for \( \varphi \).
    \DItem{def:propositional_interpretation/equivalence} \( \varphi \) and \( \psi \) are \Def{Boolean equivalent} and write \( \varphi \equiv_B \psi \) if \( \varphi[I] = \psi[I] \) for any interpretation \( I \).
  \end{defenum}
\end{definition}

\begin{definition}\label{def:propositional_theory}\cite[definition 15.1]{OpenLogic20201202}
  The \Def{closure} of a set of formulas \( \Gamma \) is defined as
  \begin{equation*}
    \Cl(\Gamma) \coloneqq \{ \varphi(x) \colon \Gamma \models_B \varphi \}.
  \end{equation*}

  A set of formulas is said to be \Def{closed} if it coincides with its closure.

  If \( \Delta \subseteq \Gamma \) and \( \Gamma = \Cl(\Delta) \), we say that \( \Gamma \) is a \Def{theory} that is \Def{axiomatized} by \( \Delta \) and that \( \Delta \) are \Def{axioms} for \( \Gamma \).

  We are usually interested in \Def{minimal systems of axioms}, that is, sets of axioms which are minimal with respect to set inclusion.
\end{definition}

\begin{example}\label{ex:axiomatic_theory}
  Examples of axiomatic theories include \fullref{remark:minimal_propositional_language} and \fullref{remark:first_order_equality} and \fullref{def:algebraic_theory}.
\end{example}

\begin{proposition}\label{thm:boolean_equivalence_relation}
  The Boolean equivalence\Tinyref{def:propositional_interpretation} \( \equiv_B \) is an equivalence relation on the set \( \Cal{F}_B \) of propositional formulas.
\end{proposition}

\begin{theorem}\label{thm:propositional_logic_boolean_algebra}
  The quotient set\Tinyref{def:order/equivalence} of propositional formulas \( \Cal{F}_B / \cong \) forms a boolean algebra\Tinyref{def:boolean_algebra} with
  \begin{itemize}
    \item top being the equivalence class \( [\top] \) of tautologies
    \item bottom being the equivalence class \( [\bot] \) of contradictions
    \item joins given by disjunctions \( \lor \) of any representatives of the equivalence classes
    \item meets given by conjunctions \( \land \)
    \item complements given by negation \( \neg \)
  \end{itemize}
\end{theorem}
\begin{proof}
  See \fullref{remark:infinite_join_meet} about handling infinitary joins and meets. Once we prove \fullref{def:binary_join_meet/associativity}, \fullref{def:binary_join_meet/commutativity} and \fullref{def:binary_join_meet/absorption}, we can define a partial order on \( \Cal{F}_B / \cong \) that allows us to extend \( \lor \) and \( \land \) to handle an infinite amount of arguments.

  \begin{description}
    \RItem{def:binary_join_meet/associativity} The functions\Tinyref{def:truth_functions} \( H_\lor \) and \( H_\land \) are associative, hence the lattice operations are associative.
    \RItem{def:binary_join_meet/commutativity} The proof is analogous to \fullref{def:binary_join_meet/associativity}.
    \RItem{def:binary_join_meet/absorption} Let \( \varphi \) and \( \psi \) be propositional formulas and \( I \) be a propositional interpretation. Then
    \begin{equation*}
      \begin{tabular}{c c | c | c}
        \( \varphi[I] \) & \( \psi[I] \) & \( H_\land(\psi[I], \varphi[I]) \) & \( H_\lor(\varphi[I], H_\land(\psi[I], \varphi[I])) \) \\
        \hline
        \( T \)          & \( T \)       & \( T \)                            & \( T \)    \\
        \( T \)          & \( F \)       & \( F \)                            & \( T \)    \\
        \( F \)          & \( T \)       & \( F \)                            & \( F \)    \\
        \( F \)          & \( F \)       & \( F \)                            & \( F \)
      \end{tabular}
    \end{equation*}
    hence \( \varphi[I] = H_\lor(\varphi[I], H_\land(\psi[I], \varphi[I])) \).

    The proof of the dual law is analogous.

    \RItem{def:distributive_lattice/distributivity} Let \( \varphi \), \( \psi \) and \( \theta \) be propositional formulas and \( I \) be a propositional interpretation. Then
    \begin{equation*}
      \begin{tabular}{c c c | c | c}
        \( \varphi[I] \) & \( \psi[I] \) & \( \theta[I] \) & \small{\( H_\land(\varphi[I], H_\lor(\psi[I], \theta[I])) \)} & \small{\( H_\lor(H_\land(\varphi[I], \psi[I]), H_\land(\varphi[I], \theta[I])) \)} \\
        \hline
        \( T \)          & \( T \)       & \( T \)         & \( T \)                                               & \( T \)    \\
        \( T \)          & \( T \)       & \( F \)         & \( T \)                                               & \( T \)    \\
        \( T \)          & \( F \)       & \( T \)         & \( T \)                                               & \( T \)    \\
        \( T \)          & \( F \)       & \( F \)         & \( F \)                                               & \( F \)    \\
        \( F \)          & \( T \)       & \( T \)         & \( F \)                                               & \( F \)    \\
        \( F \)          & \( T \)       & \( F \)         & \( F \)                                               & \( F \)    \\
        \( F \)          & \( F \)       & \( T \)         & \( F \)                                               & \( F \)    \\
        \( F \)          & \( F \)       & \( F \)         & \( F \)                                               & \( F \)
      \end{tabular}
    \end{equation*}
  \end{description}

  The join and meet induce the partial order \( \varphi \leq \psi \iff \varphi \lor \psi \equiv \psi \).

  \begin{description}
    \RItem{def:lattice/top} Fix an interpretation \( I \). A formula \( \omega \) should belong to the supremum \( \sup \Cal{F}_B \) if and only if \( \varphi \lor \omega \equiv \omega \) for any formula \( \varphi \in \Cal{F}_B \). If \( \varphi \) is a tautology, \( \varphi[I] = \top \) and thus
    \begin{equation*}
      (\varphi \lor \omega)[I] \coloneqq H_\lor(\varphi[I], \omega[I]) = \top.
    \end{equation*}

    It follows that \( \omega[I] = \top \). Since the interpretation \( I \) was arbitrary, \( \omega \) is also a tautology. Hence the top element is the equivalence class of all tautologies.

    \RItem{def:lattice/bottom} The proof is analogous to \fullref{def:lattice/top}.
  \end{description}
\end{proof}

\begin{proposition}\label{thm:boolean_equivalences}
  The following Boolean equivalences hold:
  \begin{enumerate}
    \item \( (P \land Q) \cong_B (Q \land P) \)
    \item \( (P \lor Q) \cong_B (Q \lor P) \)
    \item \( (P \iff Q) \cong_B (Q \iff P) \)
    \item \( (P \implies Q) \cong_B \neg (P \lor Q) \)
    \item \( (P \iff Q) \cong_B ((P \implies Q) \land (Q \implies P)) \)
    \item \( (P \iff Q) \cong_B ((P \land Q) \lor (\neg P \land \neg Q)) \)
    \item \( ((P \land Q) \lor R) \cong_B ((P \lor R) \land (Q \lor R)) \)
    \item \( ((P \lor Q) \land R) \cong_B ((P \land R) \lor (Q \land R)) \)
  \end{enumerate}
\end{proposition}
\begin{proof}
  All equivalences can be easily verified using the truth tables in \fullref{def:truth_functions}.
\end{proof}

\begin{definition}\label{def:material_implication}
  Fix the formula \( \varphi \coloneqq P \implies Q \). We call formulas of this form \Def{material implications}.

  \begin{defenum}
    \DItem{def:material_implication/antecedent} We call \( P \) the \Def{antecedent} of \( \varphi \).

    \DItem{def:material_implication/consequent} We call \( Q \) the \Def{consequent} of \( \varphi \).

    \DItem{def:material_implication/inverse} We call the formula \( \neg P \implies \neg Q \) the \Def{inverse} of \( \varphi \).

    \DItem{def:material_implication/converse} We call the formula \( Q \implies P \) the \Def{converse} of \( \varphi \).

    \DItem{def:material_implication/contrapositive} We call the formula \( \neg Q \implies \neg P \) the \Def{contrapositive} of \( \varphi \). It is Boolean equivalent\Tinyref{def:propositional_interpretation} to the original formula by \fullref{thm:boolean_equivalences}.
  \end{defenum}
\end{definition}

\begin{definition}\label{def:equivalence}
  Fix the formula \( \varphi \coloneqq P \iff Q \). We call formulas of this form \Def{logical equivalence}. Note that
  \begin{equation*}
    P \iff Q \models_B (P \implies Q) \land (Q \implies P).
  \end{equation*}

   Despite the symmetry of \( \land \), there is an ordering in the set \( \{ P, Q \} \) of propositions and we use this ordering. For example, instead of \( Q \implies P \), we write \( P \impliedby Q \). We say that \( P \) is a \Def{necessary condition} for \( Q \) and that \( Q \) is a \Def{sufficient condition} for \( P \).
\end{definition}

\begin{remark}\label{remark:statements_as_implications}
  Theorems in mathematics usually take the form of a material implication\Tinyref{def:material_implication} \( P \implies Q \) or even equivalence\Tinyref{def:equivalence} \( P \iff Q \). Therefore the terminology of \fullref{def:material_implication} and \fullref{def:equivalence} usually applies to statements about mathematics.
\end{remark}
